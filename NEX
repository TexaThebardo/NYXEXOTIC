-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- NYX EXOTIC - OBSIDIAN UI (100% FUNCIONANDO + SETTINGS TAB COMPLETO - DICIEMBRE 2025)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Window = Library:CreateWindow({
    Title = "NYX EXOTIC",
    Icon = 134356507686793,
    Footer = "VersiÃ³n: 0.4 Â¡Beta! | Press M to open/close",
    AutoShow = false,
    ShowCustomCursor = false,
    NotifySide = "Right"
})

local Tabs = {
    Main      = Window:AddTab("Home", "layout-dashboard"),
    Combat    = Window:AddTab("Combat", "crosshair"),
    Visuals   = Window:AddTab("Visuals", "eye"),
    Player    = Window:AddTab("Player", "user"),
    ["Auto Farm"] = Window:AddTab("Auto Farm", "zap"),
    Settings  = Window:AddTab("Settings", "settings")
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PLAYER INFO
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local PlayerInfo = Tabs.Main:AddLeftGroupbox("Player Info", "accessibility")

local UsernameLabel = PlayerInfo:AddLabel("ğŸ‘¤ Username: " .. game.Players.LocalPlayer.Name)
local DisplayLabel = PlayerInfo:AddLabel("ğŸ“ Display: @" .. game.Players.LocalPlayer.DisplayName)
local UserIDLabel = PlayerInfo:AddLabel("ğŸ”¢ User ID: " .. game.Players.LocalPlayer.UserId)
local PlaytimeLabel = PlayerInfo:AddLabel("â° Playtime: 00:00")
local RegionLabel     = PlayerInfo:AddLabel("ğŸŒ Pais/RegiÃ³n: Unknown")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SERVER iNFO
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local ServerInfo = Tabs.Main:AddRightGroupbox("Server Info", "server")
local GameLabel     = ServerInfo:AddLabel("Game: Loading...")
local CreatorLabel  = ServerInfo:AddLabel("Creator: Loading...")
local PlaceIDLabel  = ServerInfo:AddLabel("Place ID: " .. game.PlaceId)
local JobIDLabel    = ServerInfo:AddLabel("Job ID: " .. (game.JobId == "" and "Private" or string.sub(game.JobId, 1, 20).."..."))
local PlayersLabel  = ServerInfo:AddLabel("Players: " .. #game.Players:GetPlayers() .. " / " .. game.Players.MaxPlayers)

spawn(function()
    local success, info = pcall(function()
        return game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId)
    end)
    if success then
        GameLabel:SetText("Game: " .. info.Name)
        CreatorLabel:SetText("Creator: " .. (info.Creator.Name or "Roblox"))
    end
end)

-- ACTUALIZAR JUGADORES
local function UpdatePlayers()
    local current = #game.Players:GetPlayers()
    local max = game.Players.MaxPlayers
    local color = current >= max * 0.8 and "ff0000" or current >= max * 0.5 and "ffff00" or "00ff00"
    PlayersLabel:SetText("Players: <font color='#" .. color .. "'>" .. current .. " / " .. max .. "</font>")
end
UpdatePlayers()
game.Players.PlayerAdded:Connect(UpdatePlayers)
game.Players.PlayerRemoving:Connect(UpdatePlayers)

local ServerJoiner = Tabs.Main:AddLeftGroupbox("Server Joiner", "server")

-- TEXTBOX PARA PEGAR JOB ID
local JobIDInput = ServerJoiner:AddInput("JobIDInput", {
    Default = "",
    Text = "Server joiner",
    Placeholder = "Ej: abc123def456ghi789",
    Callback = function() end
})

-- BOTÃ“N: COPIAR JOB ID ACTUAL
ServerJoiner:AddButton({
    Text = "Copy Job ID",
    Func = function()
        if game.JobId ~= "" then
            JobIDInput:SetValue(game.JobId)
            setclipboard(game.JobId)
            Library:Notify("Job ID copiado y pegado en el campo", 4)
        else
            Library:Notify("Servidor privado - sin Job ID", 4)
        end
    end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SERVER JOINER 
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ServerJoiner:AddButton({
    Text = "Join Server",
    Func = function()
        local inputJobID = JobIDInput.Value
        
        if inputJobID == "" or inputJobID == "Paste Job ID here" then
            Library:Notify("Error: Ingresa un Job ID vÃ¡lido", 5)
            return
        end
        
        if string.len(inputJobID) < 20 then
            Library:Notify("Error: Job ID invÃ¡lido (muy corto)", 5)
            return
        end
        
        Library:Notify("Uniendose al servidor...", 6)
        game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, inputJobID, game.Players.LocalPlayer)
    end
})

-- OPCIONAL: BOTÃ“N LIMPIAR CAMPO
ServerJoiner:AddButton({
    Text = "Clear Field",
    Func = function()
        JobIDInput:SetValue("")
        Library:Notify("Campo limpiado", 2)
    end
})


-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SYSTEM INFO CORREGIDO - ICONOS QUE SÃ FUNCIONAN + PLATAFORMA FIX
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local SystemInfo = Tabs.Main:AddRightGroupbox("System Info", "monitor")

local FPSLabel      = SystemInfo:AddLabel("zap FPS: --")  -- zap en lugar de activity
local PingLabel     = SystemInfo:AddLabel("wifi Ping: -- ms")  -- wifi en lugar de zap
local RAMLabel      = SystemInfo:AddLabel("database RAM: -- MB")  -- database en lugar de memory-stick
local PlatformLabel = SystemInfo:AddLabel("laptop Plataforma: Detecting...")  -- laptop para PC
local ExecutorLabel = SystemInfo:AddLabel("code Executor: Detecting...")  -- code en lugar de terminal
local StatusLabel   = SystemInfo:AddLabel("check Status: Loaded")  -- check en lugar de check-circle

-- DETECCIÃ“N DE PLATAFORMA + EXECUTOR (FIX PARA TU VERSIÃ“N)
spawn(function()
    local exec = "Unknown"
    local platform = "PC"

    -- Detectar executor (tu cÃ³digo original)
    if identifyexecutor then exec = identifyexecutor()
    elseif getexecutorname then exec = getexecutorname()
    elseif syn then exec = "Synapse X"
    elseif KRNL_LOADED then exec = "Krnl"
    elseif Fluxus then exec = "Fluxus"
    elseif is_solara then exec = "Solara"
    elseif gethui then exec = "Delta / Codex"
    end

    -- Detectar plataforma (mÃ©todo simple y 100% compatible)
    local UIS = game:GetService("UserInputService")
    if UIS.TouchEnabled and not UIS.KeyboardEnabled then
        platform = "Mobile"
        if string.find(game:GetService("UserGameSettings"):GetPlatform(), "iOS") then
            platform = "iOS"
        else
            platform = "Android"
        end
    elseif UIS.GamepadEnabled then
        platform = "Console"
    else
        platform = "PC"
    end

    -- Icono segÃºn plataforma (estos SÃ funcionan)
    local platformIcon = platform == "PC" and "Laptop"
                      or platform == "Android" and "SmartPhone"
                      or platform == "iOS" and "Tablet"
                      or "Gamepad"

    PlatformLabel:SetText(platformIcon .. " Plataforma: " .. platform)
    ExecutorLabel:SetText("Code Executor: " .. exec)
    StatusLabel:SetText("check Status: ğŸŸ¢ Loaded")
end)

-- FPS EN TIEMPO REAL (con icono fijo)
local frameCount = 0
local lastUpdate = tick()
game:GetService("RunService").Heartbeat:Connect(function()
    frameCount += 1
    if tick() - lastUpdate >= 1 then
        local fps = math.floor(frameCount)
        local color = fps >= 60 and "00ff00" or fps >= 40 and "ffff00" or "ff0000"
        FPSLabel:SetText("Zap FPS: <font color='#" .. color .. "'>" .. fps .. "</font>")
        frameCount = 0
        lastUpdate = tick()
    end
end)

-- PING EN TIEMPO REAL (icono fijo)
spawn(function()
    while task.wait(1.5) do
        local ping = math.floor(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue())
        local color = ping <= 60 and "00ff00" or ping <= 120 and "ffff00" or "ff0000"
        PingLabel:SetText("Wi-Fi Ping: <font color='#" .. color .. "'>" .. ping .. " ms</font>")
    end
end)

-- RAM USAGE (icono fijo)
spawn(function()
    while task.wait(2) do
        local ram = math.floor(collectgarbage("count") / 1024)
        RAMLabel:SetText("DataBase RAM: " .. ram .. " MB")
    end
end)

-- === INFORMACIÃ“N ESTÃTICA INMEDIATA ===
GameLabel:SetText("Game: " .. game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name)

-- === DETECCIÃ“N DE EXECUTOR 100% FUNCIONAL 2025 (NUNCA FALLA) ===

-- === 4. PLAYTIME (CONTADOR REAL) ===
local startTime = tick()  -- Momento en que inyectaste el script

coroutine.wrap(function()
    while task.wait(1) do
        local elapsed = tick() - startTime
        local minutes = math.floor(elapsed / 60)
        local seconds = math.floor(elapsed % 60)
        
        -- Solo los nÃºmeros en color segÃºn tiempo
        if minutes >= 60 then
            PlaytimeLabel:SetText("â° Playtime: <font color='#00ff00'>" .. minutes .. ":" .. string.format("%02d", seconds) .. "</font>")
        elseif minutes >= 30 then
            PlaytimeLabel:SetText("â° Playtime: <font color='#ffff00'>" .. minutes .. ":" .. string.format("%02d", seconds) .. "</font>")
        elseif minutes >= 10 then
            PlaytimeLabel:SetText("â° Playtime: <font color='#ff8800'>" .. minutes .. ":" .. string.format("%02d", seconds) .. "</font>")
        else
            PlaytimeLabel:SetText("â° Playtime: <font color='#ff0000'>" .. minutes .. ":" .. string.format("%02d", seconds) .. "</font>")
        end
    end
end)()
-- === 6. ACTUALIZAR JUGADORES EN SERVIDOR ===
game.Players.PlayerAdded:Connect(function()
    PlayersLabel:SetText("Players: " .. #game.Players:GetPlayers() .. " / " .. game.Players.MaxPlayers)
end)
game.Players.PlayerRemoving:Connect(function()
    PlayersLabel:SetText("Players: " .. #game.Players:GetPlayers() .. " / " .. game.Players.MaxPlayers)
end)

-- === 7. REGIÃ“N (MEJOR MÃ‰TODO DISPONIBLE) ===
spawn(function()
    local region = "Unknown"
    pcall(function()
        region = game:GetService("LocalizationService"):GetCountryRegionForPlayerAsync(game.Players.LocalPlayer)
    end)
    RegionLabel:SetText("ğŸŒ PaÃ­s/RegiÃ³n: " .. (region or "Unknown"))
end)

-- === 8. STATUS BONITO EN VERDE ===
StatusLabel:SetText("Status: ğŸŸ¢ Â¡Loaded successfully!")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PLAYER TAB - EXPLoITS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local ExploitsBox = Tabs.Player:AddRightGroupbox("Exploits & Fun", "crown")

ExploitsBox:AddButton("Headless", function()
    local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local head = char:FindFirstChild("Head")
    if head then head.Transparency = 1 end
    local face = head:FindFirstChild("face")
    if face then face.Transparency = 1 end
end)

ExploitsBox:AddButton("Korblox", function()
    local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local rFoot = char:FindFirstChild("RightFoot")
    local rLower = char:FindFirstChild("RightLowerLeg")
    local rUpper = char:FindFirstChild("RightUpperLeg")
    if rFoot and rLower and rUpper then
        rFoot.MeshId = "http://www.roblox.com/asset/?id=902942093"
        rLower.MeshId = "http://www.roblox.com/asset/?id=902942093"
        rUpper.MeshId = "http://www.roblox.com/asset/?id=902942096"
        rUpper.TextureID = "http://roblox.com/asset/?id=902843398"
        rFoot.Transparency = 1
        rLower.Transparency = 1
    end
end)

ExploitsBox:AddButton("Beast Mode V1", function()
    local face = game.Players.LocalPlayer.Character:FindFirstChild("Head"):FindFirstChild("face")
    if face then face.Texture = "rbxassetid://209712379" end
end)

ExploitsBox:AddButton("Beast Mode V2", function()
    local face = game.Players.LocalPlayer.Character:FindFirstChild("Head"):FindFirstChild("face")
    if face then face.Texture = "rbxassetid://127959433" end
end)

ExploitsBox:AddButton("Super Happy Face", function()
    local face = game.Players.LocalPlayer.Character:FindFirstChild("Head"):FindFirstChild("face")
    if face then face.Texture = "rbxassetid://494290547" end
end)

ExploitsBox:AddButton("Playful Vampire", function()
    local face = game.Players.LocalPlayer.Character:FindFirstChild("Head"):FindFirstChild("face")
    if face then face.Texture = "rbxassetid://2409281591" end
end)

ExploitsBox:AddButton("Zombie T/OM", function()
    local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local animate = char:FindFirstChild("Animate")
    if animate then
        animate.idle.Animation1.AnimationId = "http://www.roblox.com/asset/?id=782841498"
        animate.idle.Animation2.AnimationId = "http://www.roblox.com/asset/?id=782845736"
        animate.walk.WalkAnim.AnimationId = "http://www.roblox.com/asset/?id=616168032"
        animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=616163682"
        animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=5319841935"
        animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=707829716"
        char.Humanoid.Jump = true
    end
end)

ExploitsBox:AddButton("Zombie (V2)", function()
    local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local animate = char:FindFirstChild("Animate")
    if animate then
        animate.idle.Animation1.AnimationId = "http://www.roblox.com/asset/?id=782841498"
        animate.idle.Animation2.AnimationId = "http://www.roblox.com/asset/?id=782845736"
        animate.walk.WalkAnim.AnimationId = "http://www.roblox.com/asset/?id=616168032"
        animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=616163682"
        animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=1083218792"
        animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=707829716"
        char.Humanoid.Jump = true
    end
end)

ExploitsBox:AddButton("Zombie Run/Walk Only", function()
    local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local animate = char:FindFirstChild("Animate")
    if animate then
        animate.walk.WalkAnim.AnimationId = "http://www.roblox.com/asset/?id=616168032"
        animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=616163682"
        char.Humanoid.Jump = true
    end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTO FARM - MARSHMALLOW + KEYBIND P (100% FUNCIONAL EN TU VERSIÃ“N)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local AutoFarmBox = Tabs["Auto Farm"]:AddLeftGroupbox("Auto Farm (Â¡Fix!)", "diamond")
getgenv().AutoMarshEnabled = false
getgenv().MarshInterval = 1.41 -- 1.39â€“1.45 anti-cheat safe

-- FUNCIÃ“N ENCENDER
local function StartAutoMarsh()
    if getgenv().AutoMarshEnabled then return end
    getgenv().AutoMarshEnabled = true
    Library:Notify("Auto Marshmallow â†’ ON", 5)

    task.spawn(function()
        local VIM = game:GetService("VirtualInputManager")
        local player = game.Players.LocalPlayer
        local ToolPriority = {"Water", "Sugar Block Bag", "Gelatin", "Empty Bag"}
        local index = 1

        local function pressE()
            VIM:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(0.06 + math.random(1, 5)/100)
            VIM:SendKeyEvent(false, Enum.KeyCode.E, false, game)
        end

        while getgenv().AutoMarshEnabled do
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                player.CharacterAdded:Wait()
                task.wait(3)
            end

            local target = ToolPriority[index]
            local tool = player.Backpack:FindFirstChildWhichIsA("Tool")
            if tool and string.find(string.lower(tool.Name), string.lower(target)) then
                player.Character.Humanoid:EquipTool(tool)
            else
                for _, t in player.Backpack:GetChildren() do
                    if t:IsA("Tool") and string.find(string.lower(t.Name), string.lower(target)) then
                        player.Character.Humanoid:EquipTool(t)
                        break
                    end
                end
            end

            index = index % #ToolPriority + 1
            task.wait(getgenv().MarshInterval + math.random(-8, 12)/100)
            pressE()
            task.wait(0.07)
        end
    end)
end

-- FUNCIÃ“N APAGAR
local function StopAutoMarsh()
    if not getgenv().AutoMarshEnabled then return end
    getgenv().AutoMarshEnabled = false
    if game.Players.LocalPlayer.Character then
        pcall(function() game.Players.LocalPlayer.Character.Humanoid:UnequipTools() end)
    end
    Library:Notify("Auto Marshmallow â†’ OFF", 3)
end

-- TOGGLE + KEYPICKER ENCADENADO (ESTE ES EL ÃšNICO MÃ‰TODO QUE FUNCIONA EN TU VERSIÃ“N)
AutoFarmBox:AddToggle("AutoMarsh", {
    Text = "Marshmallow",
    Default = false,
    Tooltip = "Funciona al 100% ahora mismo - Probado hace 1 minuto",
    Callback = function(state)
        if state then
            StartAutoMarsh()
        else
            StopAutoMarsh()
        end
    end
}):AddKeyPicker("AutoMarshKeybind", {
    Default = "P",           -- Tecla por defecto
    SyncToggleState = true,  -- En tu versiÃ³n SÃ funciona bien si estÃ¡ encadenado
    Mode = "Toggle",
    Text = "Keybind (P)",
    Tooltip = "Presiona P para activar/desactivar"
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PLAYER ALARM - FUNCIONES PERFECTAS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local AlarmBox = Tabs["Auto Farm"]:AddRightGroupbox("Player Alarm", "music")
-- ============== PLAYER ALARM (AHORA SE DESACTIVA 100%) ==============
getgenv().PlayerAlarm_Enabled = false
getgenv().PlayerAlarm_Radius = 15
getgenv().AlarmConnection = nil
getgenv().AlarmSounds = {}

AlarmBox:AddToggle("PlayerAlarm", {
    Text = "Player Alarm",
    Default = false,
    Callback = function(state)
        getgenv().PlayerAlarm_Enabled = state

        -- DESACTIVAR
        if not state then
            if getgenv().AlarmConnection then
                getgenv().AlarmConnection:Disconnect()
                getgenv().AlarmConnection = nil
            end
            for _, sound in pairs(getgenv().AlarmSounds) do
                if sound and sound.Parent then
                    sound:Stop()
                    sound:Destroy()
                end
            end
            getgenv().AlarmSounds = {}
            Library:Notify("Player Alarm OFF", 3)
            return
        end

        -- ACTIVAR
        Library:Notify("Player Alarm ON", 3)
        getgenv().AlarmConnection = game:GetService("RunService").Heartbeat:Connect(function()
            if not getgenv().PlayerAlarm_Enabled then return end
            if not game.Players.LocalPlayer.Character or not game.Players.LocalPlayer.Character:FindFirstChild("Head") then return end

            local myHead = game.Players.LocalPlayer.Character.Head

            for _, plr in pairs(game.Players:GetPlayers()) do
                if plr ~= game.Players.LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local dist = (myHead.Position - plr.Character.HumanoidRootPart.Position).Magnitude
                    local uid = plr.UserId

                    if dist <= getgenv().PlayerAlarm_Radius then
                        if not getgenv().AlarmSounds[uid] then
                            local head = plr.Character:FindFirstChild("Head") or plr.Character.HumanoidRootPart
                            local sound = Instance.new("Sound")
                            sound.SoundId = "rbxassetid://7594301531"
                            sound.Volume = 2
                            sound.Looped = true
                            sound.Parent = head
                            sound:Play()
                            getgenv().AlarmSounds[uid] = sound
                        end
                    else
                        if getgenv().AlarmSounds[uid] then
                            getgenv().AlarmSounds[uid]:Stop()
                            getgenv().AlarmSounds[uid]:Destroy()
                            getgenv().AlarmSounds[uid] = nil
                        end
                    end
                end
            end
        end)
    end
})

-- Slider del radio (funciona perfecto)
AlarmBox:AddSlider("AlarmRadius", {
    Text = "Alarm Radius",
    Min = 0,
    Max = 100,
    Default = 0,
    Rounding = 1,
    Callback = function(v)
        getgenv().PlayerAlarm_Radius = v
    end
})

-- ==================== PLAYER TAB â†’ CHARACTER (ANTES MOVEMENT) ====================
local CharacterBox = Tabs.Player:AddLeftGroupbox("Character", "camera")

-- ANTI AFK (evita kick por inactividad)
local AntiAFKConnection
CharacterBox:AddToggle("AntiAFK", {
    Text = "Anti-AFK",
    Default = false,
    Callback = function(state)
        if state then
            AntiAFKConnection = game:GetService("Players").LocalPlayer.Idled:Connect(function()
                game:GetService("VirtualUser"):ClickButton2(Vector2.new())
            end)
            Library:Notify("Anti-AFK Activado", 3)
        else
            if AntiAFKConnection then
                AntiAFKConnection:Disconnect()
                AntiAFKConnection = nil
            end
            Library:Notify("Anti-AFK Desactivado", 3)
        end
    end
})

-- INFINITE YIELD ADMIN COMMANDS
CharacterBox:AddButton("Infinite Yield", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
    Library:Notify("Infinite Yield cargado!", 4)
end)

-- FE RESPAWN (mata y respawnea instantÃ¡neo)
CharacterBox:AddButton("FE Respawn", function()
    local lp = game.Players.LocalPlayer
    if lp.Character and lp.Character:FindFirstChild("Humanoid") then
        lp.Character.Humanoid.Health = 0
    end
    Library:Notify("Respawneando...", 2)
end)

-- ENABLE RESET BUTTON (activa el botÃ³n de reset aunque estÃ© desactivado)
-- ENABLE RESET BUTTON COMO TOGGLE (ON/OFF)
local ResetButtonConnection

CharacterBox:AddToggle("EnableReset", {
    Text = "Enable Reset Button",
    Default = false,
    Callback = function(state)
        if state then
            -- Activar el botÃ³n de Reset
            ResetButtonConnection = game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
            Library:Notify("Reset Button activado", 3)
        else
            -- Desactivar el botÃ³n de Reset (vuelve al estado por defecto: desactivado)
            if ResetButtonConnection then
                pcall(function()
                    game:GetService("StarterGui"):SetCore("ResetButtonCallback", false)
                end)
                ResetButtonConnection = nil
            end
            Library:Notify("Reset Button desactivado", 3)
        end
    end
})

-- FULLBRIGHT FE REAL (MÃXIMA CALIDAD - COMO INFINITE YIELD)
local Lighting = game:GetService("Lighting")
local OldLighting = {
    Brightness = Lighting.Brightness,
    GlobalShadows = Lighting.GlobalShadows,
    FogEnd = Lighting.FogEnd,
    FogStart = Lighting.FogStart,
    ClockTime = Lighting.ClockTime,
    Ambient = Lighting.Ambient,
    OutdoorAmbient = Lighting.OutdoorAmbient
}

local FullbrightConnection
CharacterBox:AddToggle("Fullbright", {
    Text = "Fullbright",
    Default = false,
    Callback = function(state)
        if state then
            -- Aplicar Fullbright
            Lighting.Brightness = 3
            Lighting.GlobalShadows = false
            Lighting.FogEnd = 100000
            Lighting.FogStart = 0
            Lighting.ClockTime = 12
            Lighting.Ambient = Color3.fromRGB(255, 255, 255)
            Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)

            -- Eliminar efectos de oscuridad
            for _, v in pairs(Lighting:GetChildren()) do
                if v:IsA("BloomEffect") or v:IsA("ColorCorrectionEffect") or v:IsA("SunRaysEffect") or v:IsA("Atmosphere") then
                    v.Enabled = false
                end
            end

            -- Mantener Fullbright aunque el juego intente cambiarlo
            FullbrightConnection = Lighting.ChildAdded:Connect(function(child)
                if state and (child:IsA("BloomEffect") or child:IsA("ColorCorrectionEffect") or child:IsA("SunRaysEffect") or child:IsA("Atmosphere")) then
                    child.Enabled = false
                end
            end)

            Library:Notify("Fullbright Activado", 3)
        else
            -- Restaurar iluminaciÃ³n original
            Lighting.Brightness = OldLighting.Brightness
            Lighting.GlobalShadows = OldLighting.GlobalShadows
            Lighting.FogEnd = OldLighting.FogEnd
            Lighting.FogStart = OldLighting.FogStart
            Lighting.ClockTime = OldLighting.ClockTime
            Lighting.Ambient = OldLighting.Ambient
            Lighting.OutdoorAmbient = OldLighting.OutdoorAmbient

            -- Reactivar efectos
            for _, v in pairs(Lighting:GetChildren()) do
                if v:IsA("BloomEffect") or v:IsA("ColorCorrectionEffect") or v:IsA("SunRaysEffect") then
                    v.Enabled = true
                end
            end

            if FullbrightConnection then
                FullbrightConnection:Disconnect()
                FullbrightConnection = nil
            end

            Library:Notify("Fullbright Desactivado", 3)
        end
    end
})

-- ==================== VISUALS TAB â†’ ESP V2 (DERECHO) - CORREGIDO 100% ====================
local ESPV2Box = Tabs.Visuals:AddRightGroupbox("ESP V2 (New)", "anvil")

-- ConfiguraciÃ³n
local ToolsESP_Enabled = false
local TEXT_SIZE = 5
local MAX_WIDTH = 380
local espDrawings = {}

-- Herramientas ocultas
local HIDDEN_TOOLS = {
    "empty bag", "potato", "ghost skull face half mask", "black surgical mask", "black surgical", "skimask",
    "flour", "card", "gelatin", "lockpick", "sugar block bag", "crowbar", "water", "fake id", "fist", "phone",
    "standard clip", "speed loader", "extended clip", "heavy magazine", "drum magazine", "lockpick", "crate"
}

-- Armas peligrosas â†’ ROJO
local SPECIAL_TOOLS = {
    "prl-16", "arp9", "mpx", "honey badger pistol", "ddm4 v7 pistol", "ar pistol",
    "draco", "tec-9", "mcx", ".308 ar-10", "honey badger", "m&p-15 sport ii",
    "300 blackout", "micro draco", "micro arp", "ak draco", "suppressed mcx",
    "suppressed arp", "whiteout ar9", "fn57", "g19xext", "machete", "springfieldxd mod",
    ".308 ar-10 drum", "honey badger drum", "m&p-15 sport ii drum",
    "micro draco drum", "300 blackout drum", "micro arp drum", "ak draco drum",
    "tan 300 blk mcx", "springfieldxd drum", "mcx drum", "g19xdrum", "tec-9 drum",
    "fn57drum", "arp drum", "taurus drum", "five seven drum", "five-seven drum",
    "plr-16 drum", "g23 drum", "vp9 drum", "p80 drum", "glocks drum", "draco drum",
    "glock 20 drum", "hi-point drum", "g22drum"
}

local hidden = {}
for _, v in ipairs(HIDDEN_TOOLS) do hidden[string.lower(v)] = true end
local special = {}
for _, v in ipairs(SPECIAL_TOOLS) do special[string.lower(v)] = true end

-- Crear ESP
local function createESP(plr)
    if plr == game.Players.LocalPlayer or espDrawings[plr] then return end
    local txt = Drawing.new("Text")
    txt.Size = TEXT_SIZE
    txt.Center = true
    txt.Outline = true
    txt.OutlineColor = Color3.fromRGB(0,0,0)
    txt.Font = 2
    txt.Visible = false
    txt.Color = Color3.fromRGB(230,230,230)
    espDrawings[plr] = {text = txt}
end

-- Obtener texto de herramientas
local function getToolsText(plr)
    local tools = {}
    if plr.Character then
        local eq = plr.Character:FindFirstChildOfClass("Tool")
        if eq and not hidden[string.lower(eq.Name)] then table.insert(tools, eq.Name) end
    end
    local bp = plr:FindFirstChild("Backpack")
    if bp then
        for _, t in bp:GetChildren() do
            if t:IsA("Tool") and not hidden[string.lower(t.Name)] then
                table.insert(tools, t.Name)
            end
        end
    end
    if #tools == 0 then return nil end

    local hasSpecial = false
    for _, name in ipairs(tools) do
        if special[string.lower(name)] then  -- â† CORREGIDO AQUÃ
            hasSpecial = true
            break
        end
    end

    local color = hasSpecial and Color3.fromRGB(255, 50, 50) or Color3.fromRGB(230,230,230)

    if #tools <= 5 then
        return table.concat(tools, ", "), color
    else
        local short = {}
        for i = 1, 4 do table.insert(short, tools[i]) end
        table.insert(short, tools[5] .. " | +" .. (#tools - 4) .. " MÃ¡s")
        return table.concat(short, ", "), color
    end
end

-- Loop principal
game:GetService("RunService").Heartbeat:Connect(function()
    if not ToolsESP_Enabled then
        for _, obj in pairs(espDrawings) do
            if obj.text then obj.text.Visible = false end
        end
        return
    end

    for plr, obj in pairs(espDrawings) do
        local line, color = getToolsText(plr)
        if not line or not plr.Character or not plr.Character:FindFirstChild("Head") then
            obj.text.Visible = false
            continue
        end

        local headPos = plr.Character.Head.Position + Vector3.new(0, 3.6, 0)
        local screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(headPos)
        if not onScreen then
            obj.text.Visible = false
            continue
        end

        local size = TEXT_SIZE
        local bounds = game:GetService("TextService"):GetTextSize(line, size, Enum.Font.GothamBold, Vector2.new(99999, 50))
        while bounds.X > MAX_WIDTH and size > 11 do
            size = size - 0.5
            bounds = game:GetService("TextService"):GetTextSize(line, size, Enum.Font.GothamBold, Vector2.new(99999, 50))
        end

        obj.text.Size = size
        obj.text.Text = line
        obj.text.Color = color
        obj.text.Position = Vector2.new(screenPos.X, screenPos.Y)
        obj.text.Visible = true
    end
end)

-- Limpiar al salir
game.Players.PlayerRemoving:Connect(function(plr)
    if espDrawings[plr] then
        espDrawings[plr].text:Remove()
        espDrawings[plr] = nil
    end
end)

-- Crear ESP para jugadores
for _, p in game.Players:GetPlayers() do
    if p ~= game.Players.LocalPlayer then createESP(p) end
end
game.Players.PlayerAdded:Connect(function(p)
    if p ~= game.Players.LocalPlayer then createESP(p) end
end)

-- TOGGLE + SLIDER (SIN SPAM)
ESPV2Box:AddToggle("ToolsESP", {
    Text = "ESP Show Guns",
    Default = false,
    Callback = function(state)
        ToolsESP_Enabled = state
        Library:Notify(state and "ESP Tools V2 Activado" or "ESP Tools V2 Desactivado", 3)
    end
})

ESPV2Box:AddSlider("ESPToolsSize", {
    Text = "Guns Size",
    Min = 0,
    Max = 50,
    Default = 0,
    Rounding = 1,
    Callback = function(value)
        TEXT_SIZE = value
    end
})

-- ==================== VISUALS TAB â†’ ESP V1 (IZQUIERDO) - FINAL & PERFECTO ====================
local ESPV1Box = Tabs.Visuals:AddLeftGroupbox("ESP V1", "bookmark")

-- ConfiguraciÃ³n
local ESP_Enabled = false
local CurrentTextSize = 5
local CurrentNameColor = Color3.fromRGB(255, 255, 255)
local FriendColor = Color3.fromRGB(0, 255, 0)
local FriendsList = {}
local ESP_Holders = {}

-- Crear ESP para un jugador
local function CreateESP(plr)
    if plr == game.Players.LocalPlayer or ESP_Holders[plr] then return end
    
    local billboard = Instance.new("BillboardGui")
    local text = Instance.new("TextLabel")
    
    billboard.Name = "NameESP"
    billboard.Adornee = plr.Character:FindFirstChild("Head")
    billboard.Size = UDim2.new(0, 100, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    billboard.Parent = plr.Character
    
    text.Size = UDim2.new(1, 0, 1, 0)
    text.BackgroundTransparency = 1
    text.Text = plr.DisplayName .. " (@" .. plr.Name .. ")"
    text.TextColor3 = CurrentNameColor
    text.TextSize = CurrentTextSize
    text.Font = Enum.Font.GothamBold
    text.TextStrokeTransparency = 0
    text.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    text.Parent = billboard
    
    ESP_Holders[plr] = billboard
end

-- Actualizar todos los ESP
local function UpdateESP()
    for plr, holder in pairs(ESP_Holders) do
        if holder and holder.Parent and plr.Character and plr.Character:FindFirstChild("Head") then
            local textLabel = holder:FindFirstChild("TextLabel")
            if textLabel then
                textLabel.TextSize = CurrentTextSize
                if table.find(FriendsList, plr.Name) or table.find(FriendsList, plr.DisplayName) then
                    textLabel.TextColor3 = FriendColor
                else
                    textLabel.TextColor3 = CurrentNameColor
                end
            end
        end
    end
end

-- Nuevos jugadores
game.Players.PlayerAdded:Connect(function(plr)
    plr.CharacterAdded:Connect(function()
        if ESP_Enabled then
            task.wait(1)
            CreateESP(plr)
            UpdateESP()
        end
    end)
end)

-- Limpiar al salir
game.Players.PlayerRemoving:Connect(function(plr)
    if ESP_Holders[plr] then
        ESP_Holders[plr]:Destroy()
        ESP_Holders[plr] = nil
    end
end)

-- TOGGLE + COLORPICKERS (ENCADENADOS) + SLIDER â†’ SIN NOTIFICACIONES
ESPV1Box:AddToggle("ESPNames", {
    Text = "ESP Names",
    Default = false,
    Callback = function(state)
        ESP_Enabled = state
        
        if state then
            for _, plr in game.Players:GetPlayers() do
                if plr ~= game.Players.LocalPlayer and plr.Character and plr.Character:FindFirstChild("Head") then
                    CreateESP(plr)
                end
            end
            Library:Notify("ESP Names Activado", 3)
        else
            for _, holder in pairs(ESP_Holders) do
                if holder then holder:Destroy() end
            end
            ESP_Holders = {}
            Library:Notify("ESP Names Desactivado", 3)
        end
    end
})
:AddColorPicker("NormalColor", {
    Default = Color3.fromRGB(255, 255, 255),
    Title = "Normal Name Color",
    Transparency = 0,
    Callback = function(Value)
        CurrentNameColor = Value
        UpdateESP()
        -- SIN NOTIFICACIÃ“N
    end,
})
:AddColorPicker("FriendColor", {
    Default = Color3.fromRGB(0, 255, 0),
    Title = "Friend Name Color",
    Transparency = 0,
    Callback = function(Value)
        FriendColor = Value
        UpdateESP()
        -- SIN NOTIFICACIÃ“N
    end,
})

-- SLIDER DE TAMAÃ‘O (SIN NOTIFICACIÃ“N)
ESPV1Box:AddSlider("NameSize", {
    Text = "Name Size",
    Min = 0,
    Max = 100,
    Default = 0,
    Rounding = 1,
    Callback = function(v)
        CurrentTextSize = v
        UpdateESP()
        -- SIN NOTIFICACIÃ“N
    end
})

-- SISTEMA DE AMIGOS
local FriendInput = ESPV1Box:AddInput("FriendName", {
    Default = "Ej: xSh4dow",
    Text = "Friend's Name",
    Placeholder = "Ej: xSh4dow",
    Callback = function() end
})

ESPV1Box:AddButton("Add Friend", function()
    local name = FriendInput.Value
    if name and name ~= "" and name ~= "Ej: xSh4dow" then
        table.insert(FriendsList, name)
        Library:Notify("Amigo aÃ±adido: " .. name, 3)
        UpdateESP()
        FriendInput:SetValue("")
    else
        Library:Notify("Nombre invÃ¡lido", 3)
    end
end)

ESPV1Box:AddButton("Clear Friends", function()
    FriendsList = {}
    Library:Notify("Lista de amigos limpiada", 3)
    UpdateESP()
end)

-- ConfiguraciÃ³n
local BoxESP_Enabled = false
local BoxColor = Color3.fromRGB(255, 255, 255)
local BoxThickness = 2

local ESPBoxes = {}  -- [player] = box

-- Crear caja para un jugador
local function CreateBox(plr)
    if plr == game.Players.LocalPlayer or ESPBoxes[plr] then return end

    local box = Drawing.new("Square")
    box.Visible = false
    box.Color = BoxColor
    box.Thickness = BoxThickness
    box.Transparency = 1
    box.Filled = false

    ESPBoxes[plr] = box
end

-- Loop principal
game:GetService("RunService").RenderStepped:Connect(function()
    if not BoxESP_Enabled then
        for _, box in pairs(ESPBoxes) do
            box.Visible = false
        end
        return
    end

    for plr, box in pairs(ESPBoxes) do
        if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") or not plr.Character:FindFirstChild("Head") then
            box.Visible = false
            continue
        end

        local headPos = plr.Character.Head.Position
        local rootPos = plr.Character.HumanoidRootPart.Position

        local top = workspace.CurrentCamera:WorldToViewportPoint(headPos + Vector3.new(0, 2, 0))
        local bottom = workspace.CurrentCamera:WorldToViewportPoint(rootPos - Vector3.new(0, 3, 0))

        if top.Z < 0 or bottom.Z < 0 then
            box.Visible = false
            continue
        end

        local height = math.abs(top.Y - bottom.Y)
        local width = height * 0.6

        box.Size = Vector2.new(width, height)
        box.Position = Vector2.new(top.X - width/2, top.Y)
        box.Color = BoxColor
        box.Thickness = BoxThickness
        box.Visible = true
    end
end)

-- Limpiar al salir
game.Players.PlayerRemoving:Connect(function(plr)
    if ESPBoxes[plr] then
        ESPBoxes[plr]:Remove()
        ESPBoxes[plr] = nil
    end
end)

-- Crear para jugadores existentes
for _, plr in game.Players:GetPlayers() do
    if plr ~= game.Players.LocalPlayer then CreateBox(plr) end
end

game.Players.PlayerAdded:Connect(function(plr)
    if plr ~= game.Players.LocalPlayer then CreateBox(plr) end
end)

-- TOGGLE + COLOR + GROSOR (SIN NOTIFICACIONES EN SLIDER)
ESPV1Box:AddToggle("BoxOnly", {
    Text = "ESP Box",
    Default = false,
    Callback = function(state)
        BoxESP_Enabled = state
        Library:Notify(state and "ESP Box Activado" or "ESP Box Desactivado", 3)
    end
})
:AddColorPicker("BoxColorPicker", {
    Default = Color3.fromRGB(255, 255, 255),
    Title = "Box Color",
    Transparency = 0,
    Callback = function(col)
        BoxColor = col
    end,
})

ESPV1Box:AddSlider("BoxThickness", {
    Text = "Box Thickness",
    Min = 0,
    Max = 6,
    Default = 0,
    Rounding = 1,
    Callback = function(v)
        BoxThickness = v
    end
})

-- ==================== VISUALS TAB â†’ ESP TRACER (LÃNEAS) ====================
-- ConfiguraciÃ³n
local Tracer_Enabled = false
local Tracer_Color = Color3.fromRGB(255, 255, 255)
local Tracer_Thickness = 2
local Tracer_From = "Bottom"  -- "Bottom", "Middle", "Top"

local TracerLines = {}  -- [player] = line

-- Crear tracer para un jugador
local function CreateTracer(plr)
    if plr == game.Players.LocalPlayer or TracerLines[plr] then return end

    local line = Drawing.new("Line")
    line.Visible = false
    line.Color = Tracer_Color
    line.Thickness = Tracer_Thickness
    line.Transparency = 1

    TracerLines[plr] = line
end

-- Loop principal
game:GetService("RunService").RenderStepped:Connect(function()
    if not Tracer_Enabled then
        for _, line in pairs(TracerLines) do
            line.Visible = false
        end
        return
    end

    local screenCenterX = workspace.CurrentCamera.ViewportSize.X / 2
    local screenY = workspace.CurrentCamera.ViewportSize.Y

    local fromY
    if Tracer_From == "Bottom" then
        fromY = screenY
    elseif Tracer_From == "Middle" then
        fromY = screenY / 2
    else -- Top
        fromY = 0
    end

    for plr, line in pairs(TracerLines) do
        if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") or not plr.Character:FindFirstChild("Head") then
            line.Visible = false
            continue
        end

        local root = plr.Character.HumanoidRootPart.Position
        local head = plr.Character.Head.Position + Vector3.new(0, 1, 0)
        local targetPos = head  -- Puedes cambiar a root.Position si quieres desde los pies

        local screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(targetPos)

        if onScreen and screenPos.Z > 0 then
            line.From = Vector2.new(screenCenterX, fromY)
            line.To = Vector2.new(screenPos.X, screenPos.Y)
            line.Color = Tracer_Color
            line.Thickness = Tracer_Thickness
            line.Visible = true
        else
            line.Visible = false
        end
    end
end)

-- Limpiar al salir
game.Players.PlayerRemoving:Connect(function(plr)
    if TracerLines[plr] then
        TracerLines[plr]:Remove()
        TracerLines[plr] = nil
    end
end)

-- Crear para jugadores existentes
for _, plr in game.Players:GetPlayers() do
    if plr ~= game.Players.LocalPlayer then CreateTracer(plr) end
end

game.Players.PlayerAdded:Connect(function(plr)
    if plr ~= game.Players.LocalPlayer then CreateTracer(plr) end
end)

-- TOGGLE + COLOR + GROSOR + POSICIÃ“N
ESPV1Box:AddToggle("TracerESP", {
    Text = "ESP Tracer",
    Default = false,
    Callback = function(state)
        Tracer_Enabled = state
        Library:Notify(state and "ESP Tracer Activado" or "ESP Tracer Desactivado", 3)
    end
})
:AddColorPicker("TracerColor", {
    Default = Color3.fromRGB(255, 255, 255),
    Title = "Tracer Color",
    Transparency = 0,
    Callback = function(col)
        Tracer_Color = col
    end,
})

ESPV1Box:AddSlider("TracerThickness", {
    Text = "Tracer Thickness",
    Min = 0,
    Max = 6,
    Default = 0,
    Rounding = 1,
    Callback = function(v)
        Tracer_Thickness = v
    end
})

ESPV1Box:AddDropdown("TracerFrom", {
    Values = {"Bottom", "Middle", "Top"},
    Default = "Bottom",
    Text = "Tracer From",
    Callback = function(value)
        Tracer_From = value
    end
})

-- ==================== ESP SKELETON (R6 + R15) - 100% CORREGIDO - NUNCA SE QUEDA PEGADO ====================
local SkeletonESP_Enabled = false
local SkeletonColor = Color3.fromRGB(255, 255, 255)
local SkeletonThickness = 2
local SkeletonLines = {} -- [player] = {lines = {}, index = 1}
local Camera = workspace.CurrentCamera

-- Crear lÃ­neas para un jugador
local function CreateSkeleton(plr)
    if plr == game.Players.LocalPlayer or SkeletonLines[plr] then return end
    local lines = {}
    for i = 1, 30 do
        local line = Drawing.new("Line")
        line.Visible = false
        line.Color = SkeletonColor
        line.Thickness = SkeletonThickness
        line.Transparency = 1
        table.insert(lines, line)
    end
    SkeletonLines[plr] = { lines = lines, index = 1 }
end

-- Obtener parte compatible R6/R15
local function GetPart(char, names)
    if not char then return nil end
    for _, name in ipairs(names) do
        local part = char:FindFirstChild(name)
        if part then return part end
    end
    return nil
end

-- Dibujar lÃ­nea segura (la clave para que no se pegue)
local function DrawLineSafe(plr, part1, part2)
    local data = SkeletonLines[plr]
    if not data or not part1 or not part2 then return end

    local pos1, onScreen1 = Camera:WorldToViewportPoint(part1.Position)
    local pos2, onScreen2 = Camera:WorldToViewportPoint(part2.Position)

    -- Dibujamos SI AL MENOS UNA parte estÃ¡ visible (asÃ­ nunca se congelan)
    if onScreen1 or onScreen2 then
        local line = data.lines[data.index]
        line.From = Vector2.new(pos1.X, pos1.Y)
        line.To = Vector2.new(pos2.X, pos2.Y)
        line.Color = SkeletonColor
        line.Thickness = SkeletonThickness
        line.Visible = true
        data.index = data.index + 1
        if data.index > #data.lines then data.index = 1 end
    end
end

-- LOOP PRINCIPAL (CORREGIDO AL 100%)
game:GetService("RunService").RenderStepped:Connect(function()
    if not SkeletonESP_Enabled then
        for _, data in pairs(SkeletonLines) do
            for _, line in pairs(data.lines) do
                line.Visible = false
            end
        end
        return
    end

    -- RESETEAR TODAS LAS LÃNEAS CADA FRAME (esto evita que se queden pegadas)
    for _, data in pairs(SkeletonLines) do
        for _, line in pairs(data.lines) do
            line.Visible = false
        end
        data.index = 1
    end

    for plr, data in pairs(SkeletonLines) do
        local char = plr.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") or not char:FindFirstChild("Head") then
            continue
        end

        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid.Health <= 0 then
            continue
        end

        -- Partes del cuerpo (compatible R6 y R15)
        local Head           = char.Head
        local UpperTorso      = GetPart(char, {"UpperTorso", "Torso"})
        local LowerTorso      = GetPart(char, {"LowerTorso", "Torso"})
        local LeftUpperArm    = GetPart(char, {"LeftUpperArm", "Left Arm"})
        local LeftLowerArm    = GetPart(char, {"LeftLowerArm", "Left Arm"})
        local LeftHand        = GetPart(char, {"LeftHand", "Left Arm"})
        local RightUpperArm   = GetPart(char, {"RightUpperArm", "Right Arm"})
        local RightLowerArm   = GetPart(char, {"RightLowerArm", "Right Arm"})
        local RightHand       = GetPart(char, {"RightHand", "Right Arm"})
        local LeftUpperLeg    = GetPart(char, {"LeftUpperLeg", "Left Leg"})
        local LeftLowerLeg    = GetPart(char, {"LeftLowerLeg", "Left Leg"})
        local LeftFoot        = GetPart(char, {"LeftFoot", "Left Leg"})
        local RightUpperLeg   = GetPart(char, {"RightUpperLeg", "Right Leg"})
        local RightLowerLeg   = GetPart(char, {"RightLowerLeg", "Right Leg"})
        local RightFoot       = GetPart(char, {"RightFoot", "Right Leg"})

        local Hips = LowerTorso or UpperTorso

        -- === DIBUJAR ESQUELETO ===
        DrawLineSafe(plr, Head, UpperTorso)                    -- Cuello
        DrawLineSafe(plr, UpperTorso, LowerTorso)              -- Torso

        -- Brazos izquierdos
        DrawLineSafe(plr, UpperTorso, LeftUpperArm)
        DrawLineSafe(plr, LeftUpperArm, LeftLowerArm)
        DrawLineSafe(plr, LeftLowerArm, LeftHand)

        -- Brazos derechos
        DrawLineSafe(plr, UpperTorso, RightUpperArm)
        DrawLineSafe(plr, RightUpperArm, RightLowerArm)
        DrawLineSafe(plr, RightLowerArm, RightHand)

        -- Piernas izquierdas
        DrawLineSafe(plr, Hips, LeftUpperLeg)
        DrawLineSafe(plr, LeftUpperLeg, LeftLowerLeg)
        DrawLineSafe(plr, LeftLowerLeg, LeftFoot)

        -- Piernas derechas
        DrawLineSafe(plr, Hips, RightUpperLeg)
        DrawLineSafe(plr, RightUpperLeg, RightLowerLeg)
        DrawLineSafe(plr, RightLowerLeg, RightFoot)
    end
end)

-- Limpiar al salir del jugador
game.Players.PlayerRemoving:Connect(function(plr)
    if SkeletonLines[plr] then
        for _, line in pairs(SkeletonLines[plr].lines) do
            line:Remove()
        end
        SkeletonLines[plr] = nil
    end
end)

-- Crear skeleton para jugadores actuales y nuevos
for _, plr in ipairs(game.Players:GetPlayers()) do
    if plr ~= game.Players.LocalPlayer then
        CreateSkeleton(plr)
    end
end

game.Players.PlayerAdded:Connect(function(plr)
    if plr ~= game.Players.LocalPlayer then
        CreateSkeleton(plr)
    end
end)

-- ==================== TOGGLES Y CONFIGURACIÃ“N ====================
ESPV2Box:AddToggle("SkeletonESP", {
    Text = "ESP Skeleton (Fix)",
    Default = false,
    Callback = function(state)
        SkeletonESP_Enabled = state
        Library:Notify(state and "Skeleton ESP Activado" or "Skeleton ESP Desactivado", 3)
    end
}):AddColorPicker("SkeletonColor", {
    Default = Color3.fromRGB(255, 255, 255),
    Title = "Color del Esqueleto",
    Callback = function(color)
        SkeletonColor = color
    end
})

ESPV2Box:AddSlider("SkeletonThickness", {
    Text = "Skeleton Thickness",
    Min = 0,
    Max = 6,
    Default = 0,
    Rounding = 1,
    Callback = function(value)
        SkeletonThickness = value
    end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- COMBAT & VISUALS (vacÃ­os por ahora)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AIMLOCK 100% FUNCIONAL PARA OBSIDIAN ANTIGUA (la que tÃº tienes)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Fix del spam rojo (CoreGui)
spawn(function()
    while task.wait(10) do
        pcall(function()
            game:GetService("CoreGui").RobloxGui.Modules.Common.Locales:Destroy()
        end)
    end
end)

getgenv().Aimlock = {
    Enabled = false,
    Aiming = false,
    Part = "Head",
    OldPart = "Head",
    Radius = 80,
    TeamCheck = false,
    Predict = true,
    Prediction = 15,
    Smooth = 0.14,
    AliveCheck = false,
    Airshot = false
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local Target = nil

-- FOV Circle
local FOVCircle = Drawing.new("Circle")
FOVCircle.Radius = 80
FOVCircle.Color = Color3.fromRGB(255, 0, 70)
FOVCircle.Thickness = 1.6
FOVCircle.NumSides = 16
FOVCircle.Filled = false
FOVCircle.Transparency = 0.9
FOVCircle.Visible = false

RunService.RenderStepped:Connect(function()
    FOVCircle.Position = Vector2.new(Mouse.X, Mouse.Y + 36)
end)

local function GetClosest()
    local closest = nil
    local dist = getgenv().Aimlock.Radius

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
            if getgenv().Aimlock.TeamCheck and plr.Team == LocalPlayer.Team then continue end
            local part = plr.Character:FindFirstChild(getgenv().Aimlock.Part) or plr.Character:FindFirstChild("Head")
            if part then
                local sp, onscreen = Camera:WorldToViewportPoint(part.Position)
                if onscreen then
                    local d = (Vector2.new(sp.X, sp.Y) - Vector2.new(Mouse.X, Mouse.Y + 36)).Magnitude
                    if d < dist then
                        dist = d
                        closest = plr
                    end
                end
            end
        end
    end
    return closest
end

RunService.Heartbeat:Connect(function()
    if not getgenv().Aimlock.Enabled or not getgenv().Aimlock.Aiming then return end

    Target = GetClosest()

    if getgenv().Aimlock.AliveCheck and Target and Target.Character and Target.Character:FindFirstChild("Humanoid") and Target.Character.Humanoid.Health <= 0 then
        Target = nil
    end

    if getgenv().Aimlock.Airshot and Target and Target.Character:FindFirstChild("Humanoid") then
        if Target.Character.Humanoid.FloorMaterial == Enum.Material.Air then
            getgenv().Aimlock.Part = "RightFoot"
        else
            getgenv().Aimlock.Part = getgenv().Aimlock.OldPart
        end
    end

    if Target and Target.Character and Target.Character:FindFirstChild(getgenv().Aimlock.Part) then
        local pos = Target.Character[getgenv().Aimlock.Part].Position
        if getgenv().Aimlock.Predict then
            pos = pos + (Target.Character[getgenv().Aimlock.Part].Velocity / getgenv().Aimlock.Prediction)
        end
        if getgenv().Aimlock.Smooth > 0 then
            Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, pos), getgenv().Aimlock.Smooth)
        else
            Camera.CFrame = CFrame.new(Camera.CFrame.Position, pos)
        end
    end
end)

-- ==================== UI PARA TU VERSIÃ“N EXACTA (Ã­ndice como primer argumento) ====================

local AimBox = Tabs.Combat:AddLeftGroupbox("Aimlock (PC Only)", "sword")

-- Toggle principal + KeyPicker encadenado (esto sÃ­ funciona en tu versiÃ³n)
AimBox:AddToggle("AimlockEnabled", {  -- â† AquÃ­ va el Ã­ndice
    Text = "Aim Assist",
    Default = false,
    Tooltip = "Activa el aimlock",
    Callback = function(v)
        getgenv().Aimlock.Enabled = v
    end
}):AddKeyPicker("AimlockKey", {  -- â† AquÃ­ va el Ã­ndice del KeyPicker
    Default = "B",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Aimlock Key",
    Callback = function(v)
        getgenv().Aimlock.Aiming = v
    end
})

AimBox:AddDropdown("AimPart", {
    Values = {"Head", "UpperTorso", "HumanoidRootPart", "LowerTorso"},
    Default = 1,
    Text = "Aim Part",
    Callback = function(v)
        getgenv().Aimlock.Part = v
        getgenv().Aimlock.OldPart = v
    end
})

AimBox:AddToggle("TeamCheck", { Text = "Team Check", Default = false, Callback = function(v) getgenv().Aimlock.TeamCheck = v end })
AimBox:AddToggle("AliveCheck", { Text = "Alive Check", Default = false, Callback = function(v) getgenv().Aimlock.AliveCheck = v end })
AimBox:AddToggle("Prediction", { Text = "Prediction", Default = false, Callback = function(v) getgenv().Aimlock.Predict = v end })
AimBox:AddToggle("Airshot", { Text = "Airshot Function", Default = false, Callback = function(v) getgenv().Aimlock.Airshot = v end })

AimBox:AddSlider("Smoothness", {
    Text = "Smoothness",
    Default = 0,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(v)
        getgenv().Aimlock.Smooth = v
    end
})

AimBox:AddSlider("PredictionPower", {
    Text = "Prediction Movement",
    Default = 0,
    Min = 0,
    Max = 50,
    Rounding = 1,
    Callback = function(v)
        getgenv().Aimlock.Prediction = v
    end
})

-- FOV
local FOVBox = Tabs.Combat:AddRightGroupbox("FOV", "circle")

FOVBox:AddToggle("ShowFOV", {
    Text = "Show FOV Circle",
    Default = false,
    Callback = function(v)
        FOVCircle.Visible = v
    end
})

FOVBox:AddSlider("FOVSize", {
    Text = "FOV Radius",
    Default = 0,
    Min = 0,
    Max = 300,
    Rounding = 1,
    Callback = function(v)
        getgenv().Aimlock.Radius = v
        FOVCircle.Radius = v
    end
})

FOVBox:AddLabel("FOV Color"):AddColorPicker("FOVColor", {
    Default = Color3.fromRGB(255, 0, 70),
    Callback = function(v)
        FOVCircle.Color = v
    end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- HARDLOCK EXTREME V4 - SOLDADO 100% (NO SE MUEVE NI 1 PIXEL) - OBSIDIAN LIBRARY
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

getgenv().Hardlock = {
    Enabled = false,
    Aiming = false,
    Key = "z",
    Part = "Head",
    FOV = 100,
    Predict = true,
    Airshot = true,
    TeamCheck = false
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local Target = nil
local LockConnection = nil
local MouseLocked = false

-- FOV Circle para Hardlock
local HardlockFOVCircle = Drawing.new("Circle")
HardlockFOVCircle.Visible = false
HardlockFOVCircle.Thickness = 2
HardlockFOVCircle.Color = Color3.fromRGB(255, 0, 50)
HardlockFOVCircle.Filled = false
HardlockFOVCircle.Radius = getgenv().Hardlock.FOV
HardlockFOVCircle.Transparency = 0.8

RunService.RenderStepped:Connect(function()
    HardlockFOVCircle.Position = Vector2.new(Mouse.X, Mouse.Y + 36)
    HardlockFOVCircle.Radius = getgenv().Hardlock.FOV
end)

local function GetClosestPlayer()
    local closest = nil
    local shortestDistance = getgenv().Hardlock.FOV

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr == LocalPlayer then continue end
        if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then continue end
        if not plr.Character:FindFirstChild("Humanoid") or plr.Character.Humanoid.Health <= 0 then continue end
        if getgenv().Hardlock.TeamCheck and plr.Team == LocalPlayer.Team then continue end
        
        local part = plr.Character:FindFirstChild(getgenv().Hardlock.Part) or plr.Character.Head
        if not part then continue end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
        if not onScreen then continue end
        
        local distance = (Vector2.new(Mouse.X, Mouse.Y + 36) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
        if distance < shortestDistance then
            shortestDistance = distance
            closest = plr
        end
    end
    return closest
end

local function HardlockLoop()
    if not MouseLocked or not Target or not Target.Character then return end
   
    local char = Target.Character
    local humanoid = char:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        MouseLocked = false
        return
    end
    
    local part = char:FindFirstChild(getgenv().Hardlock.Part) or char.Head
    if not part then return end
    
    -- Airshot
    if getgenv().Hardlock.Airshot and humanoid.FloorMaterial == Enum.Material.Air then
        part = char:FindFirstChild("LowerTorso") or char:FindFirstChild("UpperTorso") or part
    end
    
    local velocity = part.AssemblyLinearVelocity
    local prediction = getgenv().Hardlock.Predict and (velocity * 0.135) or Vector3.new(0, 0, 0)
    local targetPos = part.Position + prediction + Vector3.new(0, 0.12, 0)
    
    local screenPoint, onScreen = Camera:WorldToViewportPoint(targetPos)
    if not onScreen then return end
    
    local target2D = Vector2.new(screenPoint.X, screenPoint.Y)
    local mouse2D = Vector2.new(Mouse.X, Mouse.Y + 36)
    local difference = target2D - mouse2D
    local distance = difference.Magnitude
    
    -- DEADZONE + SMOOTH CONTROLADO (LA CLAVE DEL SOLDADO)
    if distance < 6 then return end
    
    local moveX = difference.X * 0.22
    local moveY = difference.Y * 0.16
    
    moveX = math.clamp(moveX, -11, 11)
    moveY = math.clamp(moveY, -10, 10)
    
    -- APLICACIÃ“N EN PASOS PEQUEÃ‘OS (SOLDADO ESTABLE)
    mousemoverel(moveX, moveY)
    mousemoverel(moveX * 0.8, moveY * 0.7)
    mousemoverel(moveX * 0.5, moveY * 0.4)
    
    -- KILL DRIFT HORIZONTAL
    if math.abs(difference.X) > 10 then
        mousemoverel(math.clamp(difference.X * 0.65, -15, 15), 0)
    end
end

local function StartLock()
    Target = GetClosestPlayer()
    if not Target then return end
    MouseLocked = true
    if LockConnection then LockConnection:Disconnect() end
    LockConnection = RunService.RenderStepped:Connect(HardlockLoop)
end

local function StopLock()
    MouseLocked = false
    if LockConnection then
        LockConnection:Disconnect()
        LockConnection = nil
    end
    Target = nil
end

-- Key Input (convierte string a KeyCode)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    local keyName = getgenv().Hardlock.Key:upper()
    local keyCode = Enum.KeyCode[keyName]
    
    if keyCode and input.KeyCode == keyCode and getgenv().Hardlock.Enabled then
        if MouseLocked then
            StopLock()
        else
            StartLock()
        end
    end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- UI HARDLOCK - OBSIDIAN LIBRARY (ÃNDICES COMO PRIMER ARGUMENTO)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local HardlockBox = Tabs.Combat:AddRightGroupbox("Hardlock (No Work)", "mouse")

-- Toggle principal + KeyPicker encadenado
HardlockBox:AddToggle("HardlockEnabled", {
    Text = "MauseLock",
    Default = false,
    Tooltip = "Mouse lock SOLDADO (no se mueve 1 pixel)",
    Callback = function(state)
        getgenv().Hardlock.Enabled = state
        if not state then
            StopLock()
        end
    end
}):AddKeyPicker("HardlockKeybind", {
    Default = "Z",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Hardlock Key",
    Tooltip = "Tecla para hardlock",
    Callback = function(Value)
        -- Toggle funciona automÃ¡ticamente con SyncToggleState
    end
})

HardlockBox:AddDropdown("HardlockPart", {
    Values = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"},
    Default = 1,  -- Head
    Text = "Target Part",
    Tooltip = "Parte del cuerpo",
    Callback = function(part)
        getgenv().Hardlock.Part = part
    end
})

HardlockBox:AddToggle("HardlockPredict", {
    Text = "Prediction",
    Default = false,
    Tooltip = "PredicciÃ³n de movimiento",
    Callback = function(state)
        getgenv().Hardlock.Predict = state
    end
})

HardlockBox:AddToggle("HardlockAirshot", {
    Text = "Airshot Function",
    Default = false,
    Tooltip = "Aim torso si salta",
    Callback = function(state)
        getgenv().Hardlock.Airshot = state
    end
})

HardlockBox:AddToggle("HardlockTeamCheck", {
    Text = "Team Check",
    Default = false,
    Tooltip = "No lock teammates",
    Callback = function(state)
        getgenv().Hardlock.TeamCheck = state
    end
})

HardlockBox:AddSlider("HardlockFOV", {
    Text = "FOV Size",
    Default = 0,
    Min = 0,
    Max = 100,
    Rounding = 1,
    Callback = function(value)
        getgenv().Hardlock.FOV = value
    end
})

HardlockBox:AddDivider()

HardlockBox:AddToggle("HardlockShowFOV", {
    Text = "Show FOV Circle",
    Default = false,
    Tooltip = "Muestra cÃ­rculo FOV",
    Callback = function(state)
        HardlockFOVCircle.Visible = state
    end
})

HardlockBox:AddLabel("FOV Color"):AddColorPicker("HardlockFOVColor", {
    Default = Color3.fromRGB(255, 0, 50),
    Title = "Hardlock FOV Color",
    Callback = function(color)
        HardlockFOVCircle.Color = color
    end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- NYX EXOTIC 2025 - HITBOX EXPANDER 100% ORIGINAL + OBSIDIAN (SOLO PC)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Variables originales (100% igual que tu script)
local hitboxEnabled = false
local hitboxSize = 5
local selectedPart = "Head"
local connection = nil
local originalData = {}

local availableParts = {"Head", "UpperTorso", "RightUpperLeg", "LeftUpperLeg", "RightFoot", "LeftFoot"}

-- ======================= FUNCIONES 100% ORIGINALES (NO CAMBIÃ‰ NADA) =======================
local function expand()
    for _, plr in Players:GetPlayers() do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild(selectedPart) then
            local part = plr.Character[selectedPart]
            if part and part:IsA("BasePart") then
                if not originalData[plr] then
                    originalData[plr] = {
                        Size = part.Size,
                        Transparency = part.Transparency,
                        CanCollide = part.CanCollide,
                        Massless = part.Massless
                    }
                end
                part.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                part.Transparency = 0.6
                part.CanCollide = false
                part.Massless = true
            end
        end
    end
end

local function restoreAll()
    for plr, data in pairs(originalData) do
        if plr.Character and plr.Character:FindFirstChild(selectedPart) then
            local part = plr.Character[selectedPart]
            if part then
                part.Size = data.Size
                part.Transparency = data.Transparency
                part.CanCollide = data.CanCollide
                part.Massless = data.Massless
            end
        end
    end
    originalData = {}
end

-- ======================= OBSIDIAN - SOLO PARA PC =======================
local HitboxBox = Tabs.Combat:AddLeftGroupbox("Hitbox Bypass (Work)", "target")

-- Toggle principal (PC)
HitboxBox:AddToggle("HitboxPC", {
    Text = "Hitbox Expander",
    Default = false,
    Tooltip = "NYX EXOTIC 2025 - Bypass Byfron",
    Callback = function(state)
        hitboxEnabled = state

        if hitboxEnabled then
            if connection then connection:Disconnect() end
            connection = RunService.Heartbeat:Connect(expand)
            Library:Notify("NYX Hitbox âœ ON", 3)
        else
            if connection then connection:Disconnect() connection = nil end
            restoreAll()
            Library:Notify("NYX Hitbox âœ OFF", 3)
        end
    end
})

-- Dropdown para cambiar parte
HitboxBox:AddDropdown("HitboxPart", {
    Values = availableParts,
    Default = 1,
    Text = "Body Part",
    Callback = function(part)
        if hitboxEnabled then
            restoreAll()
            selectedPart = part
            task.wait(0.05)
            expand()
        else
            selectedPart = part
        end
        Library:Notify("Parte: " .. part, 2)
    end
})

-- Slider para tamaÃ±o
HitboxBox:AddSlider("HitboxSize", {
    Text = "Size",
    Default = 0,
    Min = 0,
    Max = 50,
    Rounding = 1,
    Callback = function(value)
        hitboxSize = value
        if hitboxEnabled then
            task.spawn(expand)
        end
    end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- 2D RADAR (Blissful#4992) - ADAPTADO A OBSIDIAN LIBRARY (VISUALS TAB)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = workspace.CurrentCamera

-- Cargar mÃ³dulo de lerp color
local LerpColorModule = loadstring(game:HttpGet("https://pastebin.com/raw/wRnsJeid"))()
local HealthBarLerp = LerpColorModule:Lerp(Color3.fromRGB(255, 0, 0), Color3.fromRGB(0, 255, 0))

-- ConfiguraciÃ³n del radar
getgenv().Radar = {
    Enabled = false,
    Position = Vector2.new(200, 200),
    Radius = 100,
    Scale = 1,
    TeamCheck = true,
    HealthColor = true
}

-- Drawing objects
local RadarBackground = Drawing.new("Circle")
local RadarBorder = Drawing.new("Circle")
local LocalPlayerDot = Drawing.new("Triangle")
local Dots = {}

-- Crear cÃ­rculo
local function NewCircle(transparency, color, radius, filled, thickness)
    local c = Drawing.new("Circle")
    c.Transparency = transparency
    c.Color = color
    c.Thickness = thickness or 2
    c.Filled = filled
    c.Visible = false
    c.Radius = radius
    c.NumSides = math.clamp(radius * 0.55, 10, 75)
    return c
end

-- Crear punto de jugador
local function CreatePlayerDot()
    local dot = Drawing.new("Circle")
    dot.Radius = 3
    dot.Thickness = 1
    dot.Filled = true
    dot.Visible = false
    return dot
end

-- Actualizar radar
local function UpdateRadar()
    RadarBackground.Visible = getgenv().Radar.Enabled
    RadarBorder.Visible = getgenv().Radar.Enabled
    LocalPlayerDot.Visible = getgenv().Radar.Enabled

    if not getgenv().Radar.Enabled then
        for _, dot in pairs(Dots) do
            dot.Visible = false
        end
        return
    end

    RadarBackground.Position = getgenv().Radar.Position
    RadarBackground.Radius = getgenv().Radar.Radius
    RadarBackground.Color = Color3.fromRGB(10, 10, 10)
    RadarBackground.Transparency = 0.9
    RadarBackground.Filled = true

    RadarBorder.Position = getgenv().Radar.Position
    RadarBorder.Radius = getgenv().Radar.Radius
    RadarBorder.Color = Color3.fromRGB(75, 75, 75)
    RadarBorder.Transparency = 0.75
    RadarBorder.Filled = false
    RadarBorder.Thickness = 3

    -- TriÃ¡ngulo del local player
    LocalPlayerDot.Color = Color3.fromRGB(255, 255, 255)
    LocalPlayerDot.PointA = getgenv().Radar.Position + Vector2.new(0, -6)
    LocalPlayerDot.PointB = getgenv().Radar.Position + Vector2.new(-4, 6)
    LocalPlayerDot.PointC = getgenv().Radar.Position + Vector2.new(4, 6)
    LocalPlayerDot.Filled = true
    LocalPlayerDot.Thickness = 1
end

-- FunciÃ³n relativa
local function GetRelative(pos)
    local char = LocalPlayer.Character
    if char and char.PrimaryPart then
        local pmpart = char.PrimaryPart
        local camerapos = Vector3.new(Camera.CFrame.Position.X, pmpart.Position.Y, Camera.CFrame.Position.Z)
        local newcf = CFrame.new(pmpart.Position, camerapos)
        local r = newcf:PointToObjectSpace(pos)
        return r.X, r.Z
    end
    return 0, 0
end

-- Actualizar dots
RunService.RenderStepped:Connect(function()
    if not getgenv().Radar.Enabled then return end

    for plr, dot in pairs(Dots) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character.PrimaryPart and plr.Character.Humanoid.Health > 0 then
            local hum = plr.Character.Humanoid
            local relx, rely = GetRelative(plr.Character.PrimaryPart.Position)
            local newpos = getgenv().Radar.Position - Vector2.new(relx * getgenv().Radar.Scale, rely * getgenv().Radar.Scale)

            local distance = (newpos - getgenv().Radar.Position).Magnitude
            if distance < getgenv().Radar.Radius - 2 then
                dot.Position = newpos
                dot.Radius = 3
                dot.Visible = true
            else
                local calc = (getgenv().Radar.Position - newpos).Unit * (distance - getgenv().Radar.Radius)
                dot.Position = newpos + calc
                dot.Radius = 2
                dot.Visible = true
            end

            -- Color
            if getgenv().Radar.TeamCheck and plr.Team == LocalPlayer.Team then
                dot.Color = Color3.fromRGB(0, 255, 0)
            elseif getgenv().Radar.HealthColor then
                dot.Color = HealthBarLerp(hum.Health / hum.MaxHealth)
            else
                dot.Color = Color3.fromRGB(255, 0, 0)
            end
        else
            dot.Visible = false
        end
    end
end)

-- Crear dots para jugadores existentes
for _, plr in pairs(Players:GetPlayers()) do
    if plr ~= LocalPlayer then
        Dots[plr] = CreatePlayerDot()
    end
end

Players.PlayerAdded:Connect(function(plr)
    if plr ~= LocalPlayer then
        Dots[plr] = CreatePlayerDot()
    end
end)

Players.PlayerRemoving:Connect(function(plr)
    if Dots[plr] then
        Dots[plr]:Remove()
        Dots[plr] = nil
    end
end)

-- Draggable
local draggingRadar = false
local dragOffset = Vector2.new()

UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        local mousePos = Vector2.new(Mouse.X, Mouse.Y + 36)
        if (mousePos - getgenv().Radar.Position).Magnitude < getgenv().Radar.Radius then
            draggingRadar = true
            dragOffset = getgenv().Radar.Position - mousePos
        end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        draggingRadar = false
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if draggingRadar and input.UserInputType == Enum.UserInputType.MouseMovement then
        getgenv().Radar.Position = Vector2.new(Mouse.X, Mouse.Y + 36) + dragOffset
        UpdateRadar()
    end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- UI - OBSIDIAN (VISUALS TAB)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local RadarBox = Tabs.Visuals:AddLeftGroupbox("2D Radar", "radar")

RadarBox:AddToggle("RadarEnabled", {
    Text = "Enable 2D Radar",
    Default = false,
    Callback = function(state)
        getgenv().Radar.Enabled = state
        UpdateRadar()
        Library:Notify(state and "2D Radar Activado" or "2D Radar Desactivado", 3)
    end
})

RadarBox:AddSlider("RadarSize", {
    Text = "Radar Size",
    Min = 0,
    Max = 350,
    Default = 0,
    Rounding = 1,
    Callback = function(value)
        getgenv().Radar.Radius = value
        UpdateRadar()
    end
})

RadarBox:AddToggle("RadarTeamCheck", {
    Text = "Team Check",
    Default = false,
    Callback = function(state)
        getgenv().Radar.TeamCheck = state
    end
})

RadarBox:AddToggle("RadarHealthColor", {
    Text = "Health-Based Color",
    Default = false,
    Callback = function(state)
        getgenv().Radar.HealthColor = state
    end
})

-- Inicializar
UpdateRadar()

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- OFFSCREEN ARROWS (Blissful#4992) - ADAPTADO A OBSIDIAN LIBRARY (VISUALS TAB)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

getgenv().OffscreenArrows = {
    Enabled = false,
    Distance = 80,
    Size = 16,
    Filled = true,
    Transparency = 0,
    Thickness = 1,
    Color = Color3.fromRGB(255, 255, 255),
    TeamCheck = false
}

local Arrows = {}

local function CreateArrow()
    local arrow = Drawing.new("Triangle")
    arrow.Filled = getgenv().OffscreenArrows.Filled
    arrow.Thickness = getgenv().OffscreenArrows.Thickness
    arrow.Transparency = 1 - getgenv().OffscreenArrows.Transparency
    arrow.Color = getgenv().OffscreenArrows.Color
    arrow.Visible = false
    return arrow
end

local function GetRelative(pos)
    local char = LocalPlayer.Character
    if not char or not char.PrimaryPart then return Vector2.new(0, 0) end
    local root = char.PrimaryPart.Position
    local camPos = Camera.CFrame.Position
    local relative = CFrame.new(Vector3.new(root.X, camPos.Y, root.Z), camPos):PointToObjectSpace(pos)
    return Vector2.new(relative.X, relative.Z)
end

local function RelativeToCenter(v)
    return Camera.ViewportSize / 2 - v
end

local function RotateVector(v, angle)
    local rad = math.rad(angle)
    local cos = math.cos(rad)
    local sin = math.sin(rad)
    return Vector2.new(v.X * cos - v.Y * sin, v.X * sin + v.Y * cos)
end

local function UpdateArrows()
    if not getgenv().OffscreenArrows.Enabled then
        for _, arrow in pairs(Arrows) do
            arrow.Visible = false
        end
        return
    end

    for plr, arrow in pairs(Arrows) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character.PrimaryPart and plr.Character.Humanoid.Health > 0 then
            local rootPos = plr.Character.PrimaryPart.Position
            local _, onScreen = Camera:WorldToViewportPoint(rootPos)

            if not onScreen then
                local rel = GetRelative(rootPos)
                local direction = rel.Unit
                local dist = getgenv().OffscreenArrows.Distance
                local size = getgenv().OffscreenArrows.Size / 2

                local base = direction * dist
                local left = base + RotateVector(direction, 90) * size
                local right = base + RotateVector(direction, -90) * size
                local tip = direction * (dist + getgenv().OffscreenArrows.Size)

                arrow.PointA = RelativeToCenter(left)
                arrow.PointB = RelativeToCenter(right)
                arrow.PointC = RelativeToCenter(tip)
                arrow.Visible = true

                -- Color por equipo
                if getgenv().OffscreenArrows.TeamCheck and plr.Team == LocalPlayer.Team then
                    arrow.Color = Color3.fromRGB(0, 255, 0) -- Verde = aliado
                else
                    arrow.Color = Color3.fromRGB(255, 0, 0) -- Rojo = enemigo
                end
            else
                arrow.Visible = false
            end
        else
            arrow.Visible = false
        end
    end
end

-- Crear flechas para jugadores
for _, plr in pairs(Players:GetPlayers()) do
    if plr ~= LocalPlayer then
        Arrows[plr] = CreateArrow()
    end
end

Players.PlayerAdded:Connect(function(plr)
    if plr ~= LocalPlayer then
        Arrows[plr] = CreateArrow()
    end
end)

Players.PlayerRemoving:Connect(function(plr)
    if Arrows[plr] then
        Arrows[plr]:Remove()
        Arrows[plr] = nil
    end
end)

-- Loop principal
RunService.RenderStepped:Connect(UpdateArrows)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- UI - OBSIDIAN (VISUALS TAB)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local ArrowsBox = Tabs.Visuals:AddRightGroupbox("Offscreen Arrows", "arrow-up")

ArrowsBox:AddToggle("ArrowsEnabled", {
    Text = "Offscreen Arrows",
    Default = false,
    Tooltip = "Flechas fuera de pantalla",
    Callback = function(state)
        getgenv().OffscreenArrows.Enabled = state
        Library:Notify(state and "Offscreen Arrows Activado" or "Offscreen Arrows Desactivado", 3)
    end
})

ArrowsBox:AddSlider("ArrowsDistance", {
    Text = "Distance center",
    Min = 9,
    Max = 200,
    Default = 9,
    Rounding = 1,
    Callback = function(value)
        getgenv().OffscreenArrows.Distance = value
    end
})

ArrowsBox:AddSlider("ArrowsSize", {
    Text = "Size Arrow",
    Min = 0,
    Max = 60,
    Default = 0,
    Rounding = 1,
    Callback = function(value)
        getgenv().OffscreenArrows.Size = value
    end
})

ArrowsBox:AddToggle("ArrowsTeamCheck", {
    Text = "Team Check",
    Default = false,
    Tooltip = "Verde = aliado, Rojo = enemigo",
    Callback = function(state)
        getgenv().OffscreenArrows.TeamCheck = state
    end
})

-- AUTO LOOT + HOLD COMPLETE (VirtualInputManager ONLY - INDETECTABLE 2025)
getgenv().AutoLootEnabled = false
getgenv().LootInterval = 0.85  -- RÃ¡pido y perfecto

local VIM = game:GetService("VirtualInputManager")
local player = game.Players.LocalPlayer

-- Textos que quieres auto-usar (aÃ±ade los que necesites)
local TARGET_TEXTS = {"Interact", "interact", "InteractÃºa", "Interactua"}

local targetLower = {}
for _, v in ipairs(TARGET_TEXTS) do targetLower[string.lower(v)] = true end

local function pressE(holdTime)
    holdTime = holdTime or 0
    VIM:SendKeyEvent(true, Enum.KeyCode.E, false, game)
    if holdTime > 

0.05 then
        task.wait(holdTime + math.random(5, 25)/1000) -- Timing humano
    end
    VIM:SendKeyEvent(false, Enum.KeyCode.E, false, game)
end

CharacterBox:AddToggle("AutoLootHold", {
    Text = "Auto Loot (New)",
    Default = false,
    Tooltip = "Mantiene E el tiempo exacto del HoldDuration",
    Callback = function(state)
        getgenv().AutoLootEnabled = state

        if not state then
            Library:Notify("Auto Loot + Hold â†’ OFF", 3)
            return
        end

        Library:Notify("Auto Loot + Hold â†’ ON (Completa HoldDuration)", 5)

        task.spawn(function()
            while getgenv().AutoLootEnabled do
                local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                if not hrp then
                    player.CharacterAdded:Wait()
                    task.wait(2)
                    continue
                end

                local bestPrompt = nil
                local bestDist = math.huge

                for _, obj in workspace:GetDescendants() do
                    if obj:IsA("ProximityPrompt") then
                        local text = obj.ActionText
                        if text and targetLower[string.lower(text)] then
                            local dist = (hrp.Position - obj.Parent.Position).Magnitude
                            if dist <= (obj.MaxActivationDistance + 8) and dist < bestDist then
                                bestDist = dist
                                bestPrompt = obj
                            end
                        end
                    end
                end

                if bestPrompt then
                    local hold = bestPrompt.HoldDuration
                    pressE(hold) -- MANTIENE E EXACTAMENTE EL TIEMPO NECESARIO
                    Library:Notify("Completed: " .. bestPrompt.ActionText .. " (" .. hold .. "s)", 1.2)
                    task.wait(0.2) -- PequeÃ±a pausa post-hold
                end

                task.wait(getgenv().LootInterval + math.random(-12, 18)/100)
            end
        end)
    end
})

-- Slider 
CharacterBox:AddSlider("LootSpeed", {
    Text = "Loot Speed",
    Min = 0.4,
    Max = 2.2,
    Default = 0.85,
    Rounding = 2,
    Callback = function(v)
        getgenv().LootInterval = v
    end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SISTEMA ANTI-KICK COMPLETO 2025 (INTEGRADO EN NYX EXOTIC)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local AntiKickBox = Tabs.Player:AddRightGroupbox("Anti-Kick System", "shield")

-- TOGGLE PRINCIPAL ANTI-KICK
local AntiKickEnabled = false
local AntiKickConnection
local AntiAFKConnection

AntiKickBox:AddToggle("AntiKickMain", {
    Text = "Anti-Kick Full",
    Default = false,
    Tooltip = "Protege contra AFK kick, script kicks y mÃ¡s (2025 Byfron safe)",
    Callback = function(state)
        AntiKickEnabled = state
        
        if state then
            Library:Notify("Anti-Kick Activado - ProtegerÃ© tu sesiÃ³n", 5)
            
            -- 1. ANTI-AFK KICK (mantiene actividad)
            AntiAFKConnection = game.Players.LocalPlayer.Idled:Connect(function()
                if AntiKickEnabled then
                    game:GetService("VirtualUser"):CaptureController()
                    game:GetService("VirtualUser"):ClickButton2(Vector2.new())
                end
            end)
            
            -- 2. ANTI-CHARACTER RESTRICT (evita que te quiten control)
            AntiKickConnection = game.Players.LocalPlayer.CharacterAdded:Connect(function(char)
                if AntiKickEnabled then
                    local humanoid = char:WaitForChild("Humanoid")
                    humanoid.StateChanged:Connect(function(old, new)
                        if new == Enum.HumanoidStateType.Dead or new == Enum.HumanoidStateType.Ragdoll then
                            humanoid:ChangeState(Enum.HumanoidStateType.Running)
                        end
                    end)
                end
            end)
            
            -- 3. ANTI-KICK BY SCRIPTS (bloquea kick methods comunes)
            local mt = getrawmetatable(game)
            local oldNamecall = mt.__namecall
            setreadonly(mt, false)
            mt.__namecall = newcclosure(function(self, ...)
                local method = getnamecallmethod()
                local args = {...}
                
                -- Bloquear kick methods
                if AntiKickEnabled and self == game.Players.LocalPlayer and method == "Kick" then
                    return
                end
                
                -- Bloquear destroy character
                if AntiKickEnabled and self.Name == "Character" and method == "Destroy" then
                    return
                end
                
                return oldNamecall(self, ...)
            end)
            setreadonly(mt, true)
            
        else
            Library:Notify("Anti-Kick Desactivado", 3)
            if AntiAFKConnection then AntiAFKConnection:Disconnect() end
            if AntiKickConnection then AntiKickConnection:Disconnect() end
        end
    end
})

-- ANTI-TOOL DESTROY (protege herramientas)
AntiKickBox:AddToggle("Anti-ToolDestroy", {
    Text = "Anti-Tool Destroy",
    Default = false,
    Tooltip = "Evita que scripts destruyan tus herramientas",
    Callback = function(state)
        if state then
            Library:Notify("Anti-Tool Destroy Activado", 3)
            local player = game.Players.LocalPlayer
            player.CharacterAdded:Connect(function(char)
                local humanoid = char:WaitForChild("Humanoid")
                local backpack = player:WaitForChild("Backpack")
                
                -- Proteger herramientas
                backpack.ChildRemoved:Connect(function(child)
                    if child:IsA("Tool") then
                        task.wait(0.1)
                        child.Parent = backpack
                    end
                end)
            end)
        else
            Library:Notify("Anti-Tool Destroy Desactivado", 3)
        end
    end
})

-- ANTI AFK (evita kick por inactividad)
local AntiAFKConnection
AntiKickBox:AddToggle("Anti-AFK", {
    Text = "Anti-AFK",
    Default = false,
    Callback = function(state)
        if state then
            AntiAFKConnection = game:GetService("Players").LocalPlayer.Idled:Connect(function()
                game:GetService("VirtualUser"):ClickButton2(Vector2.new())
            end)
            Library:Notify("Anti-AFK Activado", 3)
        else
            if AntiAFKConnection then
                AntiAFKConnection:Disconnect()
                AntiAFKConnection = nil
            end
            Library:Notify("Anti-AFK Desactivado", 3)
        end
    end
})

-- NOTIFICACIÃ“N INICIAL
Library:Notify("Anti-Kick System Cargado - Activa en Player Tab", 6)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SETTINGS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetFolder("NyxExotic")
ThemeManager:SetFolder("NyxExotic")
ThemeManager:ApplyToTab(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Tabs.Settings:AddLeftGroupbox("Menu"):AddToggle("CustomCursor", {
    Text = "Custom Cursor",
    Default = true,
    Callback = function(v) Library.ShowCustomCursor = v end
})
Tabs.Settings:AddLeftGroupbox("Menu"):AddLabel("Menu Bind: M (Fixed)")
Tabs.Settings:AddLeftGroupbox("Menu"):AddButton("Unload", function() Library:Unload() end)

-- Tecla M
game:GetService("UserInputService").InputBegan:Connect(function(i, gp)
    if not gp and i.KeyCode == Enum.KeyCode.M then Library:Toggle() end
end)

Library:Notify("Â¡NYX EXOTIC LOADED!", 6)
SaveManager:LoadAutoloadConfig()
