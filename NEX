local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Window = Library:CreateWindow({
    Title = "NYX EXOTIC",
    Icon = 99959252308019,
    Footer = "Versi√≥n: 2.1 ¬°Beta! | Press M to open/close",
    AutoShow = true,
    ShowCustomCursor = false,
    NotifySide = "Right"
})

local Tabs = {
    Main      = Window:AddTab("Home", "layout-dashboard"),
    Combat    = Window:AddTab("Combat", "crosshair"),
    Visuals   = Window:AddTab("Visuals", "eye"),
    Player    = Window:AddTab("Player", "user"),
    ["Auto Farm"] = Window:AddTab("Auto Farm", "zap"),
    Settings  = Window:AddTab("Settings", "settings")
}

local PlayerInfo = Tabs.Main:AddLeftGroupbox("Player Info", "accessibility")

local UsernameLabel = PlayerInfo:AddLabel("üë§ Username: " .. game.Players.LocalPlayer.Name)
local DisplayLabel = PlayerInfo:AddLabel("üìù Display: @" .. game.Players.LocalPlayer.DisplayName)
local UserIDLabel = PlayerInfo:AddLabel("üî¢ User ID: " .. game.Players.LocalPlayer.UserId)
local PlaytimeLabel = PlayerInfo:AddLabel("‚è∞ Playtime: 00:00")
local RegionLabel     = PlayerInfo:AddLabel("üåê Pais/Regi√≥n: Unknown")


local ServerInfo = Tabs.Main:AddRightGroupbox("Server Info", "server")
local GameLabel     = ServerInfo:AddLabel("Game: Loading...")
local CreatorLabel  = ServerInfo:AddLabel("Creator: Loading...")
local PlaceIDLabel  = ServerInfo:AddLabel("Place ID: " .. game.PlaceId)
local JobIDLabel    = ServerInfo:AddLabel("Job ID: " .. (game.JobId == "" and "Private" or string.sub(game.JobId, 1, 20).."..."))
local PlayersLabel  = ServerInfo:AddLabel("Players: " .. #game.Players:GetPlayers() .. " / " .. game.Players.MaxPlayers)

spawn(function()
    local success, info = pcall(function()
        return game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId)
    end)
    if success then
        GameLabel:SetText("Game: " .. info.Name)
        CreatorLabel:SetText("Creator: " .. (info.Creator.Name or "Roblox"))
    end
end)

local function UpdatePlayers()
    local current = #game.Players:GetPlayers()
    local max = game.Players.MaxPlayers
    local color = current >= max * 0.8 and "ff0000" or current >= max * 0.5 and "ffff00" or "00ff00"
    PlayersLabel:SetText("Players: <font color='#" .. color .. "'>" .. current .. " / " .. max .. "</font>")
end
UpdatePlayers()
game.Players.PlayerAdded:Connect(UpdatePlayers)
game.Players.PlayerRemoving:Connect(UpdatePlayers)

local ChangelogBox = Tabs.Main:AddLeftGroupbox("Changelog v1.6.9", "scroll-text")

ChangelogBox:AddLabel("<font color='#AF42FF'>NYX EXOTIC ‚Ä¢ 10 Dic 2025</font>", true)
ChangelogBox:AddDivider()
ChangelogBox:AddLabel("<font color='#00ff8c'>IMPLEMENTED</font>", true)
ChangelogBox:AddLabel("[+] Added Auto Spend Clip", true)
ChangelogBox:AddLabel("[+] Added Show Give Button (Mobile Only)", true)
ChangelogBox:AddLabel("[+] Added Insta proximity", true)
ChangelogBox:AddLabel("[+] Added Custom Name", true)
ChangelogBox:AddDivider()
ChangelogBox:AddLabel("<font color='#ffff64'>FIXED & REMOVE</font>", true)
ChangelogBox:AddLabel("[-] Anti-AFK removed", true)
ChangelogBox:AddLabel("[-] Anti-Kick removed", true)
ChangelogBox:AddLabel("[-] Anti-Destroyed removed", true)
ChangelogBox:AddLabel("[-] Skin change buttons removed", true)
ChangelogBox:AddDivider()
ChangelogBox:AddLabel("<font color='#FF2E2E'>COMING SOON</font>", true)
ChangelogBox:AddLabel("[‚àû] ", false)
ChangelogBox:AddLabel("[‚àû] ", false)
ChangelogBox:AddLabel("[‚àû] ", false)
ChangelogBox:AddDivider()
ChangelogBox:AddLabel("<font color='#ff9bff'>By xSh4dow/NYX</font>", true)

local SystemInfo = Tabs.Main:AddRightGroupbox("System Info", "monitor")

local FPSLabel      = SystemInfo:AddLabel("zap FPS: --")  -- zap en lugar de activity
local PingLabel     = SystemInfo:AddLabel("wifi Ping: -- ms")  -- wifi en lugar de zap
local RAMLabel      = SystemInfo:AddLabel("database RAM: -- MB")  -- database en lugar de memory-stick
local PlatformLabel = SystemInfo:AddLabel("laptop Plataforma: Detecting...")  -- laptop para PC
local ExecutorLabel = SystemInfo:AddLabel("code Executor: Detecting...")  -- code en lugar de terminal
local StatusLabel   = SystemInfo:AddLabel("check Status: Loaded")  -- check en lugar de check-circle

spawn(function()
    local exec = "Unknown"
    local platform = "PC"

    -- Detectar executor (tu c√≥digo original)
    if identifyexecutor then exec = identifyexecutor()
    elseif getexecutorname then exec = getexecutorname()
    elseif syn then exec = "Synapse X"
    elseif KRNL_LOADED then exec = "Krnl"
    elseif Fluxus then exec = "Fluxus"
    elseif is_solara then exec = "Solara"
    elseif gethui then exec = "Delta / Codex"
    end

    -- Detectar plataforma (m√©todo simple y 100% compatible)
    local UIS = game:GetService("UserInputService")
    if UIS.TouchEnabled and not UIS.KeyboardEnabled then
        platform = "Mobile"
        if string.find(game:GetService("UserGameSettings"):GetPlatform(), "iOS") then
            platform = "iOS"
        else
            platform = "Android"
        end
    elseif UIS.GamepadEnabled then
        platform = "Console"
    else
        platform = "PC"
    end

    -- Icono seg√∫n plataforma (estos S√ç funcionan)
    local platformIcon = platform == "PC" and "Laptop"
                      or platform == "Android" and "SmartPhone"
                      or platform == "iOS" and "Tablet"
                      or "Gamepad"

    PlatformLabel:SetText(platformIcon .. " Plataforma: " .. platform)
    ExecutorLabel:SetText("Code Executor: " .. exec)
    StatusLabel:SetText("check Status: üü¢ Loaded")
end)

-- FPS EN TIEMPO REAL (con icono fijo)
local frameCount = 0
local lastUpdate = tick()
game:GetService("RunService").Heartbeat:Connect(function()
    frameCount += 1
    if tick() - lastUpdate >= 1 then
        local fps = math.floor(frameCount)
        local color = fps >= 60 and "00ff00" or fps >= 40 and "ffff00" or "ff0000"
        FPSLabel:SetText("Zap FPS: <font color='#" .. color .. "'>" .. fps .. "</font>")
        frameCount = 0
        lastUpdate = tick()
    end
end)

spawn(function()
    while task.wait(1.5) do
        local ping = math.floor(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue())
        local color = ping <= 60 and "00ff00" or ping <= 120 and "ffff00" or "ff0000"
        PingLabel:SetText("Wi-Fi Ping: <font color='#" .. color .. "'>" .. ping .. " ms</font>")
    end
end)

-- RAM USAGE (icono fijo)
spawn(function()
    while task.wait(2) do
        local ram = math.floor(collectgarbage("count") / 1024)
        RAMLabel:SetText("DataBase RAM: " .. ram .. " MB")
    end
end)

GameLabel:SetText("Game: " .. game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name)

local startTime = tick()  -- Momento en que inyectaste el script

coroutine.wrap(function()
    while task.wait(1) do
        local elapsed = tick() - startTime
        local minutes = math.floor(elapsed / 60)
        local seconds = math.floor(elapsed % 60)
        
        -- Solo los n√∫meros en color seg√∫n tiempo
        if minutes >= 60 then
            PlaytimeLabel:SetText("‚è∞ Playtime: <font color='#00ff00'>" .. minutes .. ":" .. string.format("%02d", seconds) .. "</font>")
        elseif minutes >= 30 then
            PlaytimeLabel:SetText("‚è∞ Playtime: <font color='#ffff00'>" .. minutes .. ":" .. string.format("%02d", seconds) .. "</font>")
        elseif minutes >= 10 then
            PlaytimeLabel:SetText("‚è∞ Playtime: <font color='#ff8800'>" .. minutes .. ":" .. string.format("%02d", seconds) .. "</font>")
        else
            PlaytimeLabel:SetText("‚è∞ Playtime: <font color='#ff0000'>" .. minutes .. ":" .. string.format("%02d", seconds) .. "</font>")
        end
    end
end)()
-- === 6. ACTUALIZAR JUGADORES EN SERVIDOR ===
game.Players.PlayerAdded:Connect(function()
    PlayersLabel:SetText("Players: " .. #game.Players:GetPlayers() .. " / " .. game.Players.MaxPlayers)
end)
game.Players.PlayerRemoving:Connect(function()
    PlayersLabel:SetText("Players: " .. #game.Players:GetPlayers() .. " / " .. game.Players.MaxPlayers)
end)

-- === 7. REGI√ìN (MEJOR M√âTODO DISPONIBLE) ===
spawn(function()
    local region = "Unknown"
    pcall(function()
        region = game:GetService("LocalizationService"):GetCountryRegionForPlayerAsync(game.Players.LocalPlayer)
    end)
    RegionLabel:SetText("üåê Pa√≠s/Regi√≥n: " .. (region or "Unknown"))
end)

StatusLabel:SetText("Status: üü¢ ¬°Loaded successfully!")

local ExploitsBox = Tabs.Player:AddRightGroupbox("Exploits & Fun", "crown")

local AutoFarmBox = Tabs["Auto Farm"]:AddLeftGroupbox("Auto Farm (¬°Fix!)", "diamond")
getgenv().AutoMarshEnabled = false
getgenv().MarshInterval = 1.41 -- 1.39‚Äì1.45 anti-cheat safe

-- FUNCI√ìN ENCENDER
local function StartAutoMarsh()
    if getgenv().AutoMarshEnabled then return end
    getgenv().AutoMarshEnabled = true
    Library:Notify("Auto Marshmallow ‚Üí ON", 5)

    task.spawn(function()
        local VIM = game:GetService("VirtualInputManager")
        local player = game.Players.LocalPlayer
        local ToolPriority = {"Water", "Sugar Block Bag", "Gelatin", "Empty Bag"}
        local index = 1

        local function pressE()
            VIM:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(0.06 + math.random(1, 5)/100)
            VIM:SendKeyEvent(false, Enum.KeyCode.E, false, game)
        end

        while getgenv().AutoMarshEnabled do
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                player.CharacterAdded:Wait()
                task.wait(3)
            end

            local target = ToolPriority[index]
            local tool = player.Backpack:FindFirstChildWhichIsA("Tool")
            if tool and string.find(string.lower(tool.Name), string.lower(target)) then
                player.Character.Humanoid:EquipTool(tool)
            else
                for _, t in player.Backpack:GetChildren() do
                    if t:IsA("Tool") and string.find(string.lower(t.Name), string.lower(target)) then
                        player.Character.Humanoid:EquipTool(t)
                        break
                    end
                end
            end

            index = index % #ToolPriority + 1
            task.wait(getgenv().MarshInterval + math.random(-8, 12)/100)
            pressE()
            task.wait(0.07)
        end
    end)
end

-- FUNCI√ìN APAGAR
local function StopAutoMarsh()
    if not getgenv().AutoMarshEnabled then return end
    getgenv().AutoMarshEnabled = false
    if game.Players.LocalPlayer.Character then
        pcall(function() game.Players.LocalPlayer.Character.Humanoid:UnequipTools() end)
    end
    Library:Notify("Auto Marshmallow ‚Üí OFF", 3)
end

-- TOGGLE + KEYPICKER ENCADENADO (ESTE ES EL √öNICO M√âTODO QUE FUNCIONA EN TU VERSI√ìN)
AutoFarmBox:AddToggle("AutoMarsh", {
    Text = "Marshmallow",
    Default = false,
    Tooltip = "Funciona al 100% ahora mismo - Probado hace 1 minuto",
    Callback = function(state)
        if state then
            StartAutoMarsh()
        else
            StopAutoMarsh()
        end
    end
}):AddKeyPicker("AutoMarshKeybind", {
    Default = "P",           -- Tecla por defecto
    SyncToggleState = true,  -- En tu versi√≥n S√ç funciona bien si est√° encadenado
    Mode = "Toggle",
    Text = "Keybind (P)",
    Tooltip = "Presiona P para activar/desactivar"
})

local AlarmBox = Tabs["Auto Farm"]:AddRightGroupbox("Player Alarm", "music")
-- ============== PLAYER ALARM (AHORA SE DESACTIVA 100%) ==============
getgenv().PlayerAlarm_Enabled = false
getgenv().PlayerAlarm_Radius = 15
getgenv().AlarmConnection = nil
getgenv().AlarmSounds = {}

AlarmBox:AddToggle("PlayerAlarm", {
    Text = "Player Alarm",
    Default = false,
    Callback = function(state)
        getgenv().PlayerAlarm_Enabled = state

        -- DESACTIVAR
        if not state then
            if getgenv().AlarmConnection then
                getgenv().AlarmConnection:Disconnect()
                getgenv().AlarmConnection = nil
            end
            for _, sound in pairs(getgenv().AlarmSounds) do
                if sound and sound.Parent then
                    sound:Stop()
                    sound:Destroy()
                end
            end
            getgenv().AlarmSounds = {}
            Library:Notify("Player Alarm OFF", 3)
            return
        end

        -- ACTIVAR
        Library:Notify("Player Alarm ON", 3)
        getgenv().AlarmConnection = game:GetService("RunService").Heartbeat:Connect(function()
            if not getgenv().PlayerAlarm_Enabled then return end
            if not game.Players.LocalPlayer.Character or not game.Players.LocalPlayer.Character:FindFirstChild("Head") then return end

            local myHead = game.Players.LocalPlayer.Character.Head

            for _, plr in pairs(game.Players:GetPlayers()) do
                if plr ~= game.Players.LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local dist = (myHead.Position - plr.Character.HumanoidRootPart.Position).Magnitude
                    local uid = plr.UserId

                    if dist <= getgenv().PlayerAlarm_Radius then
                        if not getgenv().AlarmSounds[uid] then
                            local head = plr.Character:FindFirstChild("Head") or plr.Character.HumanoidRootPart
                            local sound = Instance.new("Sound")
                            sound.SoundId = "rbxassetid://7594301531"
                            sound.Volume = 2
                            sound.Looped = true
                            sound.Parent = head
                            sound:Play()
                            getgenv().AlarmSounds[uid] = sound
                        end
                    else
                        if getgenv().AlarmSounds[uid] then
                            getgenv().AlarmSounds[uid]:Stop()
                            getgenv().AlarmSounds[uid]:Destroy()
                            getgenv().AlarmSounds[uid] = nil
                        end
                    end
                end
            end
        end)
    end
})

AlarmBox:AddSlider("AlarmRadius", {
    Text = "Alarm Radius",
    Min = 0,
    Max = 100,
    Default = 0,
    Rounding = 1,
    Callback = function(v)
        getgenv().PlayerAlarm_Radius = v
    end
})

local CharacterBox = Tabs.Player:AddLeftGroupbox("Character", "camera")

-- INFINITE YIELD ADMIN COMMANDS
CharacterBox:AddButton("Infinite Yield", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
    Library:Notify("Infinite Yield cargado!", 4)
end)

-- FE RESPAWN (mata y respawnea instant√°neo)
CharacterBox:AddButton("FE Respawn", function()
    local lp = game.Players.LocalPlayer
    if lp.Character and lp.Character:FindFirstChild("Humanoid") then
        lp.Character.Humanoid.Health = 0
    end
    Library:Notify("Respawneando...", 2)
end)

local ResetButtonConnection

CharacterBox:AddToggle("EnableReset", {
    Text = "Enable Reset Button",
    Default = false,
    Callback = function(state)
        if state then
            -- Activar el bot√≥n de Reset
            ResetButtonConnection = game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
            Library:Notify("Reset Button activado", 3)
        else
            -- Desactivar el bot√≥n de Reset (vuelve al estado por defecto: desactivado)
            if ResetButtonConnection then
                pcall(function()
                    game:GetService("StarterGui"):SetCore("ResetButtonCallback", false)
                end)
                ResetButtonConnection = nil
            end
            Library:Notify("Reset Button desactivado", 3)
        end
    end
})

local Lighting = game:GetService("Lighting")
local OldLighting = {
    Brightness = Lighting.Brightness,
    GlobalShadows = Lighting.GlobalShadows,
    FogEnd = Lighting.FogEnd,
    FogStart = Lighting.FogStart,
    ClockTime = Lighting.ClockTime,
    Ambient = Lighting.Ambient,
    OutdoorAmbient = Lighting.OutdoorAmbient
}

local FullbrightConnection
CharacterBox:AddToggle("Fullbright", {
    Text = "Fullbright",
    Default = false,
    Callback = function(state)
        if state then
            -- Aplicar Fullbright
            Lighting.Brightness = 3
            Lighting.GlobalShadows = false
            Lighting.FogEnd = 100000
            Lighting.FogStart = 0
            Lighting.ClockTime = 12
            Lighting.Ambient = Color3.fromRGB(255, 255, 255)
            Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)

            -- Eliminar efectos de oscuridad
            for _, v in pairs(Lighting:GetChildren()) do
                if v:IsA("BloomEffect") or v:IsA("ColorCorrectionEffect") or v:IsA("SunRaysEffect") or v:IsA("Atmosphere") then
                    v.Enabled = false
                end
            end

            -- Mantener Fullbright aunque el juego intente cambiarlo
            FullbrightConnection = Lighting.ChildAdded:Connect(function(child)
                if state and (child:IsA("BloomEffect") or child:IsA("ColorCorrectionEffect") or child:IsA("SunRaysEffect") or child:IsA("Atmosphere")) then
                    child.Enabled = false
                end
            end)

            Library:Notify("Fullbright Activado", 3)
        else
            -- Restaurar iluminaci√≥n original
            Lighting.Brightness = OldLighting.Brightness
            Lighting.GlobalShadows = OldLighting.GlobalShadows
            Lighting.FogEnd = OldLighting.FogEnd
            Lighting.FogStart = OldLighting.FogStart
            Lighting.ClockTime = OldLighting.ClockTime
            Lighting.Ambient = OldLighting.Ambient
            Lighting.OutdoorAmbient = OldLighting.OutdoorAmbient

            -- Reactivar efectos
            for _, v in pairs(Lighting:GetChildren()) do
                if v:IsA("BloomEffect") or v:IsA("ColorCorrectionEffect") or v:IsA("SunRaysEffect") then
                    v.Enabled = true
                end
            end

            if FullbrightConnection then
                FullbrightConnection:Disconnect()
                FullbrightConnection = nil
            end

            Library:Notify("Fullbright Desactivado", 3)
        end
    end
})

local ESPV2Box = Tabs.Visuals:AddRightGroupbox("ESP V2 (New)", "anvil")

local Players         = game:GetService("Players")
local RunService      = game:GetService("RunService")
local TextService     = game:GetService("TextService")
local Camera          = workspace.CurrentCamera
local LocalPlayer     = Players.LocalPlayer

-- Configuraci√≥n
local ToolsESP_Enabled = false
local TEXT_SIZE        = 10
local MAX_WIDTH        = 380

local espDrawings = {}

-- Herramientas que NO se muestran
local HIDDEN_TOOLS = {
    "empty bag","marshmallow","small marshmallow bag","medium marshmallow bag","large marshmallow bag",
    "hot chips","jason mask","bandana","black gloves","potato chips","potato","ghost skull face half mask",
    "black surgical mask","black surgical","skimask","flour","card","gelatin","lockpick","sugar block bag",
    "crowbar","water","fake id","fist","phone","standard clip","speed loader","extended clip",
    "heavy magazine","drum magazine","crate"
}

-- Armas peligrosas ‚Üí COLOR MORADO
local SPECIAL_TOOLS = {
    "prl-16","arp9","g21s drum","mpx","honey badger pistol","ddm4 v7 pistol","ar pistol","draco","tec-9","mcx",
    ".308 ar-10","honey badger","m&p-15 sport ii","300 blackout","micro draco","micro arp","ak draco",
    "suppressed mcx","suppressed arp","whiteout ar9","whiteout arp9","fn57","g19xext","machete",
    "springfieldxd mod",".308 ar-10 drum","honey badger drum","m&p-15 sport ii drum","micro draco drum",
    "300 blackout drum","micro arp drum","ak draco drum","tan 300 blk mcx","springfieldxd drum","mcx drum",
    "g19xdrum","tec-9 drum","fn57drum","arp drum","taurus drum","five seven drum","five-seven drum",
    "plr-16 drum","g23 drum","vp9 drum","p80 drum","glocks drum","draco drum","glock 20 drum",
    "hi-point drum","g22drum","binary black draco","binary g17 gen 5","binary 300 blackout arp",
    "binary 6in ar9","ddm4 v7 drum","mpx drum","g26 clear drum","black micro drac","arp9 clear drum",
    "black micro draco"
}

-- Convertimos a min√∫sculas una sola vez (m√°s r√°pido)
local hidden  = {}
local special = {}
for _,v in ipairs(HIDDEN_TOOLS)  do hidden[string.lower(v)]  = true end
for _,v in ipairs(SPECIAL_TOOLS) do special[string.lower(v)] = true end

-- Crear Drawing una sola vez por jugador
local function createESP(plr)
    if plr == LocalPlayer or espDrawings[plr] then return end

    local txt = Drawing.new("Text")
    txt.Size         = TEXT_SIZE
    txt.Center       = true
    txt.Outline      = true
    txt.OutlineColor = Color3.new(0,0,0)
    txt.Font         = Drawing.Fonts.GothamBold or 2
    txt.Visible      = false
    txt.Color        = Color3.fromRGB(230,230,230)

    espDrawings[plr] = { text = txt }
end

-- Obtiene el texto y color de las herramientas (optimizado)
local function getToolsText(plr)
    local tools = {}

    -- Herramienta equipada
    local char = plr.Character
    if char then
        local eq = char:FindFirstChildOfClass("Tool")
        if eq and not hidden[string.lower(eq.Name)] then
            table.insert(tools, eq.Name)
        end
    end

    -- Backpack
    local bp = plr:FindFirstChild("Backpack")
    if bp then
        for _, tool in ipairs(bp:GetChildren()) do
            if tool:IsA("Tool") and not hidden[string.lower(tool.Name)] then
                table.insert(tools, tool.Name)
            end
        end
    end

    if #tools == 0 then return nil end

    -- Detectar si tiene arma peligrosa
    local hasSpecial = false
    for _, name in ipairs(tools) do
        if special[string.lower(name)] then
            hasSpecial = true
            break
        end
    end

    local color = hasSpecial and Color3.fromRGB(169, 39, 245) or Color3.fromRGB(255, 255, 255)

    -- Si son pocas herramientas ‚Üí mostrar todas
    if #tools <= 5 then
        return table.concat(tools, ", "), color
    end

    -- Si son muchas ‚Üí abreviar
    local short = {}
    for i = 1, 4 do table.insert(short, tools[i]) end
    table.insert(short, tools[5] .. " | +" .. (#tools - 4) .. " M√°s")
    return table.concat(short, ", "), color
end

-- Heartbeat principal (muy optimizado)
RunService.Heartbeat:Connect(function()
    if not ToolsESP_Enabled then
        for _, obj in pairs(espDrawings) do
            obj.text.Visible = false
        end
        return
    end

    for plr, obj in pairs(espDrawings) do
        local line, color = getToolsText(plr)

        local head = plr.Character and plr.Character:FindFirstChild("Head")
        if not line or not head then
            obj.text.Visible = false
            continue
        end

        local headPos = head.Position + Vector3.new(0, 3.6, 0)
        local screenPos, onScreen = Camera:WorldToViewportPoint(headPos)
        if not onScreen then
            obj.text.Visible = false
            continue
        end

        -- Ajuste autom√°tico de tama√±o si el texto es muy ancho
        local size = TEXT_SIZE
        if size > 11 then
            local bounds = TextService:GetTextSize(line, size, Enum.Font.GothamBold, Vector2.new(1e5, 50))
            while bounds.X > MAX_WIDTH and size > 11 do
                size -= 0.5
                bounds = TextService:GetTextSize(line, size, Enum.Font.GothamBold, Vector2.new(1e5, 50))
            end
        end

        local txt = obj.text
        txt.Size     = size
        txt.Text     = line
        txt.Color    = color
        txt.Position = Vector2.new(screenPos.X, screenPos.Y)
        txt.Visible  = true
    end
end)

-- Limpiar al salir del juego
Players.PlayerRemoving:Connect(function(plr)
    local data = espDrawings[plr]
    if data then
        data.text:Remove()
        espDrawings[plr] = nil
    end
end)

-- Crear ESP para jugadores existentes y nuevos
for _, p in Players:GetPlayers() do
    if p ~= LocalPlayer then createESP(p) end
end
Players.PlayerAdded:Connect(function(p)
    if p ~= LocalPlayer then createESP(p) end
end)

-- TOGGLE + SLIDER (sin spam y m√°s limpio)
ESPV2Box:AddToggle("ToolsESP", {
    Text = "ESP Show Guns",
    Default = false,
    Callback = function(state)
        ToolsESP_Enabled = state
        Library:Notify(state and "ESP Tools V2 Activado" or "ESP Tools V2 Desactivado", 3)
    end
})

ESPV2Box:AddSlider("ESPToolsSize", {
    Text = "Guns Size",
    Min = 0,
    Max = 100,
    Default = 0,
    Rounding = 1,
    Callback = function(v)
        TEXT_SIZE = v
    end
})

local ESPV1Box = Tabs.Visuals:AddLeftGroupbox("ESP V1", "bookmark")

local ESP_Enabled = false
local CurrentTextSize = 18
local CurrentNameColor = Color3.fromRGB(255, 255, 255)
local FriendColor = Color3.fromRGB(0, 255, 0)
local FriendsList = {}
local ESP_Holders = {}

local function CreateESP(plr)
    if plr == game.Players.LocalPlayer then return end
    if ESP_Holders[plr] then ESP_Holders[plr]:Destroy() end

    local function MakeESP()
        if not ESP_Enabled then return end
        local char = plr.Character
        if not char or not char:FindFirstChild("Head") then return end

        local billboard = Instance.new("BillboardGui")
        local text = Instance.new("TextLabel")

        billboard.Name = "NameESP"
        billboard.Adornee = char.Head
        billboard.Size = UDim2.new(0, 200, 0, 50)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.Parent = char

        text.Size = UDim2.new(1, 0, 1, 0)
        text.BackgroundTransparency = 1
        text.Text = plr.DisplayName
        text.TextSize = CurrentTextSize
        text.Font = Enum.Font.GothamBold
        text.TextStrokeTransparency = 0
        text.TextStrokeColor3 = Color3.new(0,0,0)
        text.TextColor3 = (table.find(FriendsList, plr.Name) or table.find(FriendsList, plr.DisplayName)) and FriendColor or CurrentNameColor
        text.Parent = billboard

        ESP_Holders[plr] = billboard
    end

    -- Crear ahora si ya tiene personaje
    if plr.Character then MakeESP() end

    -- ¬°¬°ESTO ES LO QUE HAC√çA FALTA!! ‚Üí Reconectar cada vez que reaparece
    plr.CharacterAdded:Connect(function()
        task.wait(0.5)  -- Esperar a que cargue bien el personaje
        if ESP_Enabled then
            MakeESP()
        end
    end)
end

local function UpdateESP()
    for plr, holder in pairs(ESP_Holders) do
        if holder and holder.Parent then
            local label = holder:FindFirstChild("TextLabel")
            if label then
                label.TextSize = CurrentTextSize
                local isFriend = table.find(FriendsList, plr.Name) or table.find(FriendsList, plr.DisplayName)
                label.TextColor3 = isFriend and FriendColor or CurrentNameColor
            end
        end
    end
end

ESPV1Box:AddToggle("ESPNames", {
    Text = "ESP Names",
    Default = false,
    Callback = function(state)
        ESP_Enabled = state

        if state then
            -- Todos los jugadores actuales + futuros
            for _, plr in ipairs(game.Players:GetPlayers()) do
                if plr ~= game.Players.LocalPlayer then
                    CreateESP(plr)
                end
            end

            -- Nuevos jugadores
            game.Players.PlayerAdded:Connect(function(plr)
                CreateESP(plr)
            end)

            Library:Notify("ESP Names Activado", 3)
        else
            -- Apagar todo
            for _, holder in pairs(ESP_Holders) do
                if holder then holder:Destroy() end
            end
            ESP_Holders = {}
            Library:Notify("ESP Names Desactivado", 3)
        end
    end
})
:AddColorPicker("NormalColor", {
    Default = Color3.fromRGB(255, 255, 255),
    Title = "Normal Name Color",
    Transparency = 0,
    Callback = function(v) CurrentNameColor = v UpdateESP() end
})
:AddColorPicker("FriendColor", {
    Default = Color3.fromRGB(0, 255, 0),
    Title = "Friend Name Color",
    Transparency = 0,
    Callback = function(v) FriendColor = v UpdateESP() end
})

ESPV1Box:AddSlider("NameSize", {
    Text = "Name Size",
    Min = 0,
    Max = 100,
    Default = 0,
    Rounding = 1,
    Callback = function(v) CurrentTextSize = v UpdateESP() end
})

-- ==================== AMIGOS ====================
local FriendInput = ESPV1Box:AddInput("FriendName", {
    Default = "Ej: xSh4dow",
    Text = "Friend's Name",
    Placeholder = "Ej: xSh4dow",
    Callback = function() end
})

ESPV1Box:AddButton("Add Friend", function()
    local name = FriendInput.Value
    if name ~= "" and name ~= "Ej: xSh4dow" and not table.find(FriendsList, name) then
        table.insert(FriendsList, name)
        Library:Notify("Amigo a√±adido: "..name, 3)
        UpdateESP()
        FriendInput:SetValue("")
    end
end)

ESPV1Box:AddButton("Clear Friends", function()
    FriendsList = {}
    Library:Notify("Lista limpiada", 3)
    UpdateESP()
end)

-- ==================== ESP BOX ULTRA OPTIMIZADO (SOLO LO ESENCIAL) ====================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local BoxESP_Enabled = false
local BoxColor = Color3.fromRGB(255, 255, 255)
local BoxThickness = 2
local ESPBoxes = {}  -- [player] = Drawing Square

-- Crear caja una sola vez por jugador
local function CreateBox(plr)
    if plr == LocalPlayer or ESPBoxes[plr] then return end

    local box = Drawing.new("Square")
    box.Visible = false
    box.Color = BoxColor
    box.Thickness = BoxThickness
    box.Transparency = 1
    box.Filled = false

    ESPBoxes[plr] = box
end

-- Limpiar al salir del servidor
Players.PlayerRemoving:Connect(function(plr)
    if ESPBoxes[plr] then
        ESPBoxes[plr]:Remove()
        ESPBoxes[plr] = nil
    end
end)

-- Crear cajas para jugadores actuales y futuros
for _, plr in Players:GetPlayers() do
    if plr ~= LocalPlayer then CreateBox(plr) end
end
Players.PlayerAdded:Connect(function(plr)
    if plr ~= LocalPlayer then CreateBox(plr) end
end)

-- LOOP PRINCIPAL OPTIMIZADO (0 lag)
RunService.RenderStepped:Connect(function()
    if not BoxESP_Enabled then
        for _, box in ESPBoxes do box.Visible = false end
        return
    end

    for plr, box in ESPBoxes do
        local char = plr.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") or not char:FindFirstChild("Head") then
            box.Visible = false
            continue
        end

        local headPos = char.Head.Position + Vector3.new(0, 2.5, 0)
        local rootPos = char.HumanoidRootPart.Position - Vector3.new(0, 3.5, 0)

        local top, onScreenTop = Camera:WorldToViewportPoint(headPos)
        local bottom, onScreenBottom = Camera:WorldToViewportPoint(rootPos)

        if not onScreenTop or not onScreenBottom or top.Z < 0 or bottom.Z < 0 then
            box.Visible = false
            continue
        end

        local height = math.abs(top.Y - bottom.Y)
        local width = height * 0.45

        box.Size = Vector2.new(width, height)
        box.Position = Vector2.new(top.X - width/2, top.Y)
        box.Color = BoxColor
        box.Thickness = BoxThickness
        box.Visible = true
    end
end)

-- ==================== UI - SOLO TOGGLE + COLOR + THICKNESS ====================
ESPV1Box:AddToggle("BoxOnly", {
    Text = "ESP Box",
    Default = false,
    Callback = function(state)
        BoxESP_Enabled = state
        Library:Notify(state and "ESP Box Activado" or "ESP Box Desactivado", 3)
    end
})
:AddColorPicker("BoxColorPicker", {
    Default = Color3.fromRGB(255, 255, 255),
    Title = "Box Color",
    Transparency = 0,
    Callback = function(col)
        BoxColor = col
    end
})

ESPV1Box:AddSlider("BoxThickness", {
    Text = "Box Thickness",
    Min = 0,
    Max = 5,
    Default = 0,
    Rounding = 1,
    Callback = function(v)
        BoxThickness = v
    end
})

local Tracer_Enabled = false
local Tracer_Color = Color3.fromRGB(255, 255, 255)
local Tracer_Thickness = 2
local Tracer_From = "Bottom"  -- "Bottom", "Middle", "Top"

local TracerLines = {}  -- [player] = line

-- Crear tracer para un jugador
local function CreateTracer(plr)
    if plr == game.Players.LocalPlayer or TracerLines[plr] then return end

    local line = Drawing.new("Line")
    line.Visible = false
    line.Color = Tracer_Color
    line.Thickness = Tracer_Thickness
    line.Transparency = 1

    TracerLines[plr] = line
end

-- Loop principal
game:GetService("RunService").RenderStepped:Connect(function()
    if not Tracer_Enabled then
        for _, line in pairs(TracerLines) do
            line.Visible = false
        end
        return
    end

    local screenCenterX = workspace.CurrentCamera.ViewportSize.X / 2
    local screenY = workspace.CurrentCamera.ViewportSize.Y

    local fromY
    if Tracer_From == "Bottom" then
        fromY = screenY
    elseif Tracer_From == "Middle" then
        fromY = screenY / 2
    else -- Top
        fromY = 0
    end

    for plr, line in pairs(TracerLines) do
        if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") or not plr.Character:FindFirstChild("Head") then
            line.Visible = false
            continue
        end

        local root = plr.Character.HumanoidRootPart.Position
        local head = plr.Character.Head.Position + Vector3.new(0, 1, 0)
        local targetPos = head  -- Puedes cambiar a root.Position si quieres desde los pies

        local screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(targetPos)

        if onScreen and screenPos.Z > 0 then
            line.From = Vector2.new(screenCenterX, fromY)
            line.To = Vector2.new(screenPos.X, screenPos.Y)
            line.Color = Tracer_Color
            line.Thickness = Tracer_Thickness
            line.Visible = true
        else
            line.Visible = false
        end
    end
end)

-- Limpiar al salir
game.Players.PlayerRemoving:Connect(function(plr)
    if TracerLines[plr] then
        TracerLines[plr]:Remove()
        TracerLines[plr] = nil
    end
end)

-- Crear para jugadores existentes
for _, plr in game.Players:GetPlayers() do
    if plr ~= game.Players.LocalPlayer then CreateTracer(plr) end
end

game.Players.PlayerAdded:Connect(function(plr)
    if plr ~= game.Players.LocalPlayer then CreateTracer(plr) end
end)

-- TOGGLE + COLOR + GROSOR + POSICI√ìN
ESPV1Box:AddToggle("TracerESP", {
    Text = "ESP Tracer",
    Default = false,
    Callback = function(state)
        Tracer_Enabled = state
        Library:Notify(state and "ESP Tracer Activado" or "ESP Tracer Desactivado", 3)
    end
})
:AddColorPicker("TracerColor", {
    Default = Color3.fromRGB(255, 255, 255),
    Title = "Tracer Color",
    Transparency = 0,
    Callback = function(col)
        Tracer_Color = col
    end,
})

ESPV1Box:AddSlider("TracerThickness", {
    Text = "Tracer Thickness",
    Min = 0,
    Max = 6,
    Default = 0,
    Rounding = 1,
    Callback = function(v)
        Tracer_Thickness = v
    end
})

ESPV1Box:AddDropdown("TracerFrom", {
    Values = {"Bottom", "Middle", "Top"},
    Default = "Bottom",
    Text = "Tracer From",
    Callback = function(value)
        Tracer_From = value
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local Skeleton_Enabled = false
local Skeleton_Color = Color3.fromRGB(255, 255, 255)
local Skeleton_Thickness = 2
local Skeleton_Lines = {}  -- [plr] = {line1, line2, ...}

-- Mapeo de huesos (R6 + R15)
local Bones = {
    {"Head", {"UpperTorso", "Torso"}},
    {"UpperTorso", {"LowerTorso", "Torso"}},
    {"UpperTorso", {"LeftUpperArm", "Left Arm"}},
    {"LeftUpperArm", {"LeftLowerArm", "Left Arm"}},
    {"LeftLowerArm", {"LeftHand", "Left Arm"}},
    {"UpperTorso", {"RightUpperArm", "Right Arm"}},
    {"RightUpperArm", {"RightLowerArm", "Right Arm"}},
    {"RightLowerArm", {"RightHand", "Right Arm"}},
    {"LowerTorso", {"LeftUpperLeg", "Left Leg"}},
    {"LeftUpperLeg", {"LeftLowerLeg", "Left Leg"}},
    {"LeftLowerLeg", {"LeftFoot", "Left Leg"}},
    {"LowerTorso", {"RightUpperLeg", "Right Leg"}},
    {"RightUpperLeg", {"RightLowerLeg", "Right Leg"}},
    {"RightLowerLeg", {"RightFoot", "Right Leg"}}
}

local function GetPart(char, names)
    for _, name in ipairs(names) do
        local part = char:FindFirstChild(name)
        if part then return part end
    end
end

-- Crear l√≠neas una sola vez
local function CreateSkeleton(plr)
    if plr == LocalPlayer or Skeleton_Lines[plr] then return end

    local lines = {}
    for i = 1, 14 do
        local line = Drawing.new("Line")
        line.Visible = false
        line.Color = Skeleton_Color
        line.Thickness = Skeleton_Thickness
        line.Transparency = 1
        table.insert(lines, line)
    end
    Skeleton_Lines[plr] = {lines = lines, used = 0}
end

-- Limpiar al salir
Players.PlayerRemoving:Connect(function(plr)
    if Skeleton_Lines[plr] then
        for _, line in pairs(Skeleton_Lines[plr].lines) do
            line:Remove()
        end
        Skeleton_Lines[plr] = nil
    end
end)

-- Crear para todos
for _, plr in Players:GetPlayers() do if plr ~= LocalPlayer then CreateSkeleton(plr) end end
Players.PlayerAdded:Connect(function(plr) if plr ~= LocalPlayer then CreateSkeleton(plr) end end)

-- LOOP FINAL - NUNCA SE QUEDA PEGADO
RunService.Heartbeat:Connect(function()
    if not Skeleton_Enabled then
        for _, data in pairs(Skeleton_Lines) do
            for _, line in pairs(data.lines) do
                line.Visible = false
            end
            data.used = 0
        end
        return
    end

    -- Resetear TODAS las l√≠neas cada frame
    for _, data in pairs(Skeleton_Lines) do
        for i = 1, data.used do
            data.lines[i].Visible = false
        end
        data.used = 0
    end

    for plr, data in pairs(Skeleton_Lines) do
        local char = plr.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") or not char:FindFirstChild("Head") then
            continue
        end

        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum and hum.Health <= 0 then continue end

        for _, bone in ipairs(Bones) do
            local part1 = GetPart(char, {bone[1]})
            local part2 = GetPart(char, bone[2])

            if part1 and part2 then
                local screen1, onScreen1 = Camera:WorldToViewportPoint(part1.Position)
                local screen2, onScreen2 = Camera:WorldToViewportPoint(part2.Position)

                -- Solo dibujar si al menos una parte est√° en pantalla
                if onScreen1 or onScreen2 then
                    data.used = data.used + 1
                    if data.used > #data.lines then break end

                    local line = data.lines[data.used]
                    line.From = Vector2.new(screen1.X, screen1.Y)
                    line.To = Vector2.new(screen2.X, screen2.Y)
                    line.Color = Skeleton_Color
                    line.Thickness = Skeleton_Thickness
                    line.Visible = true
                end
            end
        end
    end
end)

-- ==================== UI - LIMPIO Y FUNCIONAL ====================
ESPV2Box:AddToggle("SkeletonESP", {
    Text = "ESP Skeleton",
    Default = false,
    Callback = function(v)
        Skeleton_Enabled = v
        Library:Notify(v and "Skeleton ESP Activado" or "Skeleton ESP Desactivado", 3)
    end
}):AddColorPicker("SkeletonColor", {
    Default = Color3.fromRGB(255, 255, 255),
    Title = "Skeleton Color",
    Callback = function(c) Skeleton_Color = c end
})

ESPV2Box:AddSlider("SkeletonThickness", {
    Text = "Thickness",
    Min = 0,
    Max = 5,
    Default = 1,
    Rounding = 1,
    Callback = function(v) Skeleton_Thickness = v end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

getgenv().OffscreenArrows = {
    Enabled = false,
    Distance = 80,
    Size = 16,
    Filled = true,
    Transparency = 0,
    Thickness = 1,
    Color = Color3.fromRGB(255, 255, 255),
    TeamCheck = false
}

local Arrows = {}

local function CreateArrow()
    local arrow = Drawing.new("Triangle")
    arrow.Filled = getgenv().OffscreenArrows.Filled
    arrow.Thickness = getgenv().OffscreenArrows.Thickness
    arrow.Transparency = 1 - getgenv().OffscreenArrows.Transparency
    arrow.Color = getgenv().OffscreenArrows.Color
    arrow.Visible = false
    return arrow
end

local function GetRelative(pos)
    local char = LocalPlayer.Character
    if not char or not char.PrimaryPart then return Vector2.new(0, 0) end
    local root = char.PrimaryPart.Position
    local camPos = Camera.CFrame.Position
    local relative = CFrame.new(Vector3.new(root.X, camPos.Y, root.Z), camPos):PointToObjectSpace(pos)
    return Vector2.new(relative.X, relative.Z)
end

local function RelativeToCenter(v)
    return Camera.ViewportSize / 2 - v
end

local function RotateVector(v, angle)
    local rad = math.rad(angle)
    local cos = math.cos(rad)
    local sin = math.sin(rad)
    return Vector2.new(v.X * cos - v.Y * sin, v.X * sin + v.Y * cos)
end

local function UpdateArrows()
    if not getgenv().OffscreenArrows.Enabled then
        for _, arrow in pairs(Arrows) do
            arrow.Visible = false
        end
        return
    end

    for plr, arrow in pairs(Arrows) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character.PrimaryPart and plr.Character.Humanoid.Health > 0 then
            local rootPos = plr.Character.PrimaryPart.Position
            local _, onScreen = Camera:WorldToViewportPoint(rootPos)

            if not onScreen then
                local rel = GetRelative(rootPos)
                local direction = rel.Unit
                local dist = getgenv().OffscreenArrows.Distance
                local size = getgenv().OffscreenArrows.Size / 2

                local base = direction * dist
                local left = base + RotateVector(direction, 90) * size
                local right = base + RotateVector(direction, -90) * size
                local tip = direction * (dist + getgenv().OffscreenArrows.Size)

                arrow.PointA = RelativeToCenter(left)
                arrow.PointB = RelativeToCenter(right)
                arrow.PointC = RelativeToCenter(tip)
                arrow.Visible = true

                -- Color por equipo
                if getgenv().OffscreenArrows.TeamCheck and plr.Team == LocalPlayer.Team then
                    arrow.Color = Color3.fromRGB(0, 255, 0) -- Verde = aliado
                else
                    arrow.Color = Color3.fromRGB(255, 0, 0) -- Rojo = enemigo
                end
            else
                arrow.Visible = false
            end
        else
            arrow.Visible = false
        end
    end
end

-- Crear flechas para jugadores
for _, plr in pairs(Players:GetPlayers()) do
    if plr ~= LocalPlayer then
        Arrows[plr] = CreateArrow()
    end
end

Players.PlayerAdded:Connect(function(plr)
    if plr ~= LocalPlayer then
        Arrows[plr] = CreateArrow()
    end
end)

Players.PlayerRemoving:Connect(function(plr)
    if Arrows[plr] then
        Arrows[plr]:Remove()
        Arrows[plr] = nil
    end
end)

-- Loop principal
RunService.RenderStepped:Connect(UpdateArrows)

local ArrowsBox = Tabs.Visuals:AddRightGroupbox("Offscreen Arrows", "arrow-up")

ArrowsBox:AddToggle("ArrowsEnabled", {
    Text = "Offscreen Arrows",
    Default = false,
    Tooltip = "Flechas fuera de pantalla",
    Callback = function(state)
        getgenv().OffscreenArrows.Enabled = state
        Library:Notify(state and "Offscreen Arrows Activado" or "Offscreen Arrows Desactivado", 3)
    end
})

ArrowsBox:AddSlider("ArrowsDistance", {
    Text = "Distance center",
    Min = 9,
    Max = 200,
    Default = 9,
    Rounding = 1,
    Callback = function(value)
        getgenv().OffscreenArrows.Distance = value
    end
})

ArrowsBox:AddSlider("ArrowsSize", {
    Text = "Size Arrow",
    Min = 0,
    Max = 60,
    Default = 0,
    Rounding = 1,
    Callback = function(value)
        getgenv().OffscreenArrows.Size = value
    end
})

ArrowsBox:AddToggle("ArrowsTeamCheck", {
    Text = "Team Check",
    Default = false,
    Tooltip = "Verde = aliado, Rojo = enemigo",
    Callback = function(state)
        getgenv().OffscreenArrows.TeamCheck = state
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local HealthBarEnabled = false          -- El toggle lo cambia
local OffsetX = 40                      -- El slider lo cambia
local Drawings = {}                     -- Guarda los dibujos de cada jugador
local TargetHeight = {}                 -- Altura objetivo del fill
local CurrentHeight = {}                -- Altura actual (para animaci√≥n suave)

-- Funci√≥n que crea los dibujos para un jugador
local function CreateHealthBar(player)
    if player == LocalPlayer then return end
    if Drawings[player] then return end

    -- Fondo negro
    local background = Drawing.new("Square")
    background.Visible = false
    background.Filled = true
    background.Color = Color3.new(0, 0, 0)
    background.Transparency = 0.6
    background.Thickness = 1

    -- Relleno de vida (verde/amarillo/rojo)
    local healthFill = Drawing.new("Square")
    healthFill.Visible = false
    healthFill.Filled = true
    healthFill.Color = Color3.fromRGB(0, 255, 0)
    healthFill.Transparency = 1

    -- Texto del porcentaje
    local healthText = Drawing.new("Text")
    healthText.Visible = false
    healthText.Size = 14
    healthText.Center = true
    healthText.Outline = true
    healthText.Color = Color3.new(1, 1, 1)
    healthText.Font = 2

    -- Guardamos todo
    Drawings[player] = {
        bg = background,
        fill = healthFill,
        text = healthText
    }

    TargetHeight[player] = 0
    CurrentHeight[player] = 0
end

-- Crear barras para jugadores que ya est√°n en el server
for _, player in ipairs(Players:GetPlayers()) do
    CreateHealthBar(player)
end

-- Cuando entra un nuevo jugador
Players.PlayerAdded:Connect(function(player)
    CreateHealthBar(player)
end)

-- Cuando sale un jugador, limpiamos sus dibujos
Players.PlayerRemoving:Connect(function(player)
    if Drawings[player] then
        Drawings[player].bg:Remove()
        Drawings[player].fill:Remove()
        Drawings[player].text:Remove()
        Drawings[player] = nil
        TargetHeight[player] = nil
        CurrentHeight[player] = nil
    end
end)

-- Bucle principal (se ejecuta cada frame)
RunService.RenderStepped:Connect(function()
    if not HealthBarEnabled then
        -- Ocultar todo si est√° desactivado
        for _, data in pairs(Drawings) do
            data.bg.Visible = false
            data.fill.Visible = false
            data.text.Visible = false
        end
        return
    end

    for player, objects in pairs(Drawings) do
        local character = player.Character
        if not character or not character:FindFirstChild("HumanoidRootPart") then
            objects.bg.Visible = false
            objects.fill.Visible = false
            objects.text.Visible = false
            CurrentHeight[player] = 0
            continue
        end

        local torso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
        local humanoid = character:FindFirstChildOfClass("Humanoid")

        if not torso or not humanoid or humanoid.Health <= 0 then
            objects.bg.Visible = false
            objects.fill.Visible = false
            objects.text.Visible = false
            CurrentHeight[player] = 0
            continue
        end

        local screenPos, onScreen = Camera:WorldToViewportPoint(torso.Position)
        if not onScreen or screenPos.Z < 0 then
            objects.bg.Visible = false
            objects.fill.Visible = false
            objects.text.Visible = false
            CurrentHeight[player] = 0
            continue
        end

        -- C√°lculo de tama√±o seg√∫n distancia
        local distance = (Camera.CFrame.Position - torso.Position).Magnitude
        local scaleFactor = math.clamp(150 / distance, 0.5, 2)
        local barHeight = math.clamp(35 * scaleFactor, 35, 80)

        local healthPercent = humanoid.Health / humanoid.MaxHealth
        TargetHeight[player] = (barHeight - 4) * healthPercent

        local xPosition = screenPos.X + OffsetX
        local yPosition = screenPos.Y - barHeight / 2

        -- Fondo negro
        objects.bg.Position = Vector2.new(xPosition - 3, yPosition)
        objects.bg.Size = Vector2.new(6, barHeight)
        objects.bg.Visible = true

        -- Texto del porcentaje
        objects.text.Text = math.floor(healthPercent * 100) .. "%"
        objects.text.Position = Vector2.new(xPosition, yPosition - 18)
        objects.text.Size = math.clamp(12 + scaleFactor * 4, 12, 18)
        objects.text.Visible = true

        -- Color del fill seg√∫n vida
        if healthPercent > 0.6 then
            objects.fill.Color = Color3.fromRGB(0, 255, 0)   -- Verde
        elseif healthPercent > 0.3 then
            objects.fill.Color = Color3.fromRGB(255, 255, 0) -- Amarillo
        else
            objects.fill.Color = Color3.fromRGB(255, 0, 0)   -- Rojo
        end

        -- Animaci√≥n suave del fill
        local current = CurrentHeight[player]
        local newHeight = current + (TargetHeight[player] - current) * 0.25
        CurrentHeight[player] = newHeight

        objects.fill.Position = Vector2.new(xPosition - 2, yPosition + barHeight - newHeight - 2)
        objects.fill.Size = Vector2.new(4, newHeight)
        objects.fill.Visible = true
    end
end)

-- TU UI (Kavo, Linoria, etc.) - ESTO ES LO QUE FALTABA
ESPV2Box:AddToggle("HealthBarPro", {
    Text = "Health Bar Pro",
    Default = false,
    Callback = function(value)
        HealthBarEnabled = value
    end
})

ESPV2Box:AddSlider("HealthDistance", {
    Text = "Distancia de la barra",
    Min = 20,
    Max = 100,
    Default = 40,
    Rounding = 1,
    Callback = function(value)
        OffsetX = value
    end
})

spawn(function()
    while task.wait(10) do
        pcall(function()
            game:GetService("CoreGui").RobloxGui.Modules.Common.Locales:Destroy()
        end)
    end
end)

getgenv().Aimlock = {
    Enabled = false,
    Aiming = false,
    Part = "Head",
    OldPart = "Head",
    Radius = 80,
    TeamCheck = false,
    Predict = true,
    Prediction = 15,
    Smooth = 0.14,
    AliveCheck = false,
    Airshot = false
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local Target = nil

-- FOV Circle
local FOVCircle = Drawing.new("Circle")
FOVCircle.Radius = 80
FOVCircle.Color = Color3.fromRGB(255, 0, 70)
FOVCircle.Thickness = 1.6
FOVCircle.NumSides = 16
FOVCircle.Filled = false
FOVCircle.Transparency = 0.9
FOVCircle.Visible = false

RunService.RenderStepped:Connect(function()
    FOVCircle.Position = Vector2.new(Mouse.X, Mouse.Y + 36)
end)

local function GetClosest()
    local closest = nil
    local dist = getgenv().Aimlock.Radius

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
            if getgenv().Aimlock.TeamCheck and plr.Team == LocalPlayer.Team then continue end
            local part = plr.Character:FindFirstChild(getgenv().Aimlock.Part) or plr.Character:FindFirstChild("Head")
            if part then
                local sp, onscreen = Camera:WorldToViewportPoint(part.Position)
                if onscreen then
                    local d = (Vector2.new(sp.X, sp.Y) - Vector2.new(Mouse.X, Mouse.Y + 36)).Magnitude
                    if d < dist then
                        dist = d
                        closest = plr
                    end
                end
            end
        end
    end
    return closest
end

RunService.Heartbeat:Connect(function()
    if not getgenv().Aimlock.Enabled or not getgenv().Aimlock.Aiming then return end

    Target = GetClosest()

    if getgenv().Aimlock.AliveCheck and Target and Target.Character and Target.Character:FindFirstChild("Humanoid") and Target.Character.Humanoid.Health <= 0 then
        Target = nil
    end

    if getgenv().Aimlock.Airshot and Target and Target.Character:FindFirstChild("Humanoid") then
        if Target.Character.Humanoid.FloorMaterial == Enum.Material.Air then
            getgenv().Aimlock.Part = "RightFoot"
        else
            getgenv().Aimlock.Part = getgenv().Aimlock.OldPart
        end
    end

    if Target and Target.Character and Target.Character:FindFirstChild(getgenv().Aimlock.Part) then
        local pos = Target.Character[getgenv().Aimlock.Part].Position
        if getgenv().Aimlock.Predict then
            pos = pos + (Target.Character[getgenv().Aimlock.Part].Velocity / getgenv().Aimlock.Prediction)
        end
        if getgenv().Aimlock.Smooth > 0 then
            Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, pos), getgenv().Aimlock.Smooth)
        else
            Camera.CFrame = CFrame.new(Camera.CFrame.Position, pos)
        end
    end
end)

local AimBox = Tabs.Combat:AddLeftGroupbox("Aimlock (PC Only)", "sword")

-- Toggle principal + KeyPicker encadenado (esto s√≠ funciona en tu versi√≥n)
AimBox:AddToggle("AimlockEnabled", {  -- ‚Üê Aqu√≠ va el √≠ndice
    Text = "Aim Assist",
    Default = false,
    Tooltip = "Activa el aimlock",
    Callback = function(v)
        getgenv().Aimlock.Enabled = v
    end
}):AddKeyPicker("AimlockKey", {  -- ‚Üê Aqu√≠ va el √≠ndice del KeyPicker
    Default = "B",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Aimlock Key",
    Callback = function(v)
        getgenv().Aimlock.Aiming = v
    end
})

AimBox:AddDropdown("AimPart", {
    Values = {"Head", "UpperTorso", "HumanoidRootPart", "LowerTorso"},
    Default = 1,
    Text = "Aim Part",
    Callback = function(v)
        getgenv().Aimlock.Part = v
        getgenv().Aimlock.OldPart = v
    end
})

AimBox:AddToggle("TeamCheck", { Text = "Team Check", Default = false, Callback = function(v) getgenv().Aimlock.TeamCheck = v end })
AimBox:AddToggle("AliveCheck", { Text = "Alive Check", Default = false, Callback = function(v) getgenv().Aimlock.AliveCheck = v end })
AimBox:AddToggle("Prediction", { Text = "Prediction", Default = false, Callback = function(v) getgenv().Aimlock.Predict = v end })
AimBox:AddToggle("Airshot", { Text = "Airshot Function", Default = false, Callback = function(v) getgenv().Aimlock.Airshot = v end })

AimBox:AddSlider("Smoothness", {
    Text = "Smoothness",
    Default = 0,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(v)
        getgenv().Aimlock.Smooth = v
    end
})

AimBox:AddSlider("PredictionPower", {
    Text = "Prediction Movement",
    Default = 0,
    Min = 0,
    Max = 50,
    Rounding = 1,
    Callback = function(v)
        getgenv().Aimlock.Prediction = v
    end
})

-- FOV
local FOVBox = Tabs.Combat:AddRightGroupbox("FOV", "circle")

FOVBox:AddToggle("ShowFOV", {
    Text = "Show FOV Circle",
    Default = false,
    Callback = function(v)
        FOVCircle.Visible = v
    end
})

FOVBox:AddSlider("FOVSize", {
    Text = "FOV Radius",
    Default = 0,
    Min = 0,
    Max = 300,
    Rounding = 1,
    Callback = function(v)
        getgenv().Aimlock.Radius = v
        FOVCircle.Radius = v
    end
})

FOVBox:AddLabel("FOV Color"):AddColorPicker("FOVColor", {
    Default = Color3.fromRGB(255, 0, 70),
    Callback = function(v)
        FOVCircle.Color = v
    end
})

getgenv().Hardlock = {
    Enabled = false,
    Aiming = false,
    Key = "z",
    Part = "Head",
    FOV = 100,
    Predict = true,
    Airshot = true,
    TeamCheck = false
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local Target = nil
local LockConnection = nil
local MouseLocked = false

-- FOV Circle para Hardlock
local HardlockFOVCircle = Drawing.new("Circle")
HardlockFOVCircle.Visible = false
HardlockFOVCircle.Thickness = 2
HardlockFOVCircle.Color = Color3.fromRGB(255, 0, 50)
HardlockFOVCircle.Filled = false
HardlockFOVCircle.Radius = getgenv().Hardlock.FOV
HardlockFOVCircle.Transparency = 0.8

RunService.RenderStepped:Connect(function()
    HardlockFOVCircle.Position = Vector2.new(Mouse.X, Mouse.Y + 36)
    HardlockFOVCircle.Radius = getgenv().Hardlock.FOV
end)

local function GetClosestPlayer()
    local closest = nil
    local shortestDistance = getgenv().Hardlock.FOV

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr == LocalPlayer then continue end
        if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then continue end
        if not plr.Character:FindFirstChild("Humanoid") or plr.Character.Humanoid.Health <= 0 then continue end
        if getgenv().Hardlock.TeamCheck and plr.Team == LocalPlayer.Team then continue end
        
        local part = plr.Character:FindFirstChild(getgenv().Hardlock.Part) or plr.Character.Head
        if not part then continue end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
        if not onScreen then continue end
        
        local distance = (Vector2.new(Mouse.X, Mouse.Y + 36) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
        if distance < shortestDistance then
            shortestDistance = distance
            closest = plr
        end
    end
    return closest
end

local function HardlockLoop()
    if not MouseLocked or not Target or not Target.Character then return end
   
    local char = Target.Character
    local humanoid = char:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        MouseLocked = false
        return
    end
    
    local part = char:FindFirstChild(getgenv().Hardlock.Part) or char.Head
    if not part then return end
    
    -- Airshot
    if getgenv().Hardlock.Airshot and humanoid.FloorMaterial == Enum.Material.Air then
        part = char:FindFirstChild("LowerTorso") or char:FindFirstChild("UpperTorso") or part
    end
    
    local velocity = part.AssemblyLinearVelocity
    local prediction = getgenv().Hardlock.Predict and (velocity * 0.135) or Vector3.new(0, 0, 0)
    local targetPos = part.Position + prediction + Vector3.new(0, 0.12, 0)
    
    local screenPoint, onScreen = Camera:WorldToViewportPoint(targetPos)
    if not onScreen then return end
    
    local target2D = Vector2.new(screenPoint.X, screenPoint.Y)
    local mouse2D = Vector2.new(Mouse.X, Mouse.Y + 36)
    local difference = target2D - mouse2D
    local distance = difference.Magnitude
    
    -- DEADZONE + SMOOTH CONTROLADO (LA CLAVE DEL SOLDADO)
    if distance < 6 then return end
    
    local moveX = difference.X * 0.22
    local moveY = difference.Y * 0.16
    
    moveX = math.clamp(moveX, -11, 11)
    moveY = math.clamp(moveY, -10, 10)
    
    -- APLICACI√ìN EN PASOS PEQUE√ëOS (SOLDADO ESTABLE)
    mousemoverel(moveX, moveY)
    mousemoverel(moveX * 0.8, moveY * 0.7)
    mousemoverel(moveX * 0.5, moveY * 0.4)
    
    -- KILL DRIFT HORIZONTAL
    if math.abs(difference.X) > 10 then
        mousemoverel(math.clamp(difference.X * 0.65, -15, 15), 0)
    end
end

local function StartLock()
    Target = GetClosestPlayer()
    if not Target then return end
    MouseLocked = true
    if LockConnection then LockConnection:Disconnect() end
    LockConnection = RunService.RenderStepped:Connect(HardlockLoop)
end

local function StopLock()
    MouseLocked = false
    if LockConnection then
        LockConnection:Disconnect()
        LockConnection = nil
    end
    Target = nil
end

-- Key Input (convierte string a KeyCode)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    local keyName = getgenv().Hardlock.Key:upper()
    local keyCode = Enum.KeyCode[keyName]
    
    if keyCode and input.KeyCode == keyCode and getgenv().Hardlock.Enabled then
        if MouseLocked then
            StopLock()
        else
            StartLock()
        end
    end
end)

local HardlockBox = Tabs.Combat:AddRightGroupbox("Hardlock (No Work)", "mouse")

-- Toggle principal + KeyPicker encadenado
HardlockBox:AddToggle("HardlockEnabled", {
    Text = "MauseLock",
    Default = false,
    Tooltip = "Mouse lock SOLDADO (no se mueve 1 pixel)",
    Callback = function(state)
        getgenv().Hardlock.Enabled = state
        if not state then
            StopLock()
        end
    end
}):AddKeyPicker("HardlockKeybind", {
    Default = "Z",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Hardlock Key",
    Tooltip = "Tecla para hardlock",
    Callback = function(Value)
        -- Toggle funciona autom√°ticamente con SyncToggleState
    end
})

HardlockBox:AddDropdown("HardlockPart", {
    Values = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"},
    Default = 1,  -- Head
    Text = "Target Part",
    Tooltip = "Parte del cuerpo",
    Callback = function(part)
        getgenv().Hardlock.Part = part
    end
})

HardlockBox:AddToggle("HardlockPredict", {
    Text = "Prediction",
    Default = false,
    Tooltip = "Predicci√≥n de movimiento",
    Callback = function(state)
        getgenv().Hardlock.Predict = state
    end
})

HardlockBox:AddToggle("HardlockAirshot", {
    Text = "Airshot Function",
    Default = false,
    Tooltip = "Aim torso si salta",
    Callback = function(state)
        getgenv().Hardlock.Airshot = state
    end
})

HardlockBox:AddToggle("HardlockTeamCheck", {
    Text = "Team Check",
    Default = false,
    Tooltip = "No lock teammates",
    Callback = function(state)
        getgenv().Hardlock.TeamCheck = state
    end
})

HardlockBox:AddSlider("HardlockFOV", {
    Text = "FOV Size",
    Default = 0,
    Min = 0,
    Max = 100,
    Rounding = 1,
    Callback = function(value)
        getgenv().Hardlock.FOV = value
    end
})

HardlockBox:AddDivider()

HardlockBox:AddToggle("HardlockShowFOV", {
    Text = "Show FOV Circle",
    Default = false,
    Tooltip = "Muestra c√≠rculo FOV",
    Callback = function(state)
        HardlockFOVCircle.Visible = state
    end
})

HardlockBox:AddLabel("FOV Color"):AddColorPicker("HardlockFOVColor", {
    Default = Color3.fromRGB(255, 0, 50),
    Title = "Hardlock FOV Color",
    Callback = function(color)
        HardlockFOVCircle.Color = color
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Variables originales (100% igual que tu script)
local hitboxEnabled = false
local hitboxSize = 5
local selectedPart = "Head"
local connection = nil
local originalData = {}

local availableParts = {"Head", "UpperTorso", "RightUpperLeg", "LeftUpperLeg", "RightFoot", "LeftFoot"}

local function expand()
    for _, plr in Players:GetPlayers() do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild(selectedPart) then
            local part = plr.Character[selectedPart]
            if part and part:IsA("BasePart") then
                if not originalData[plr] then
                    originalData[plr] = {
                        Size = part.Size,
                        Transparency = part.Transparency,
                        CanCollide = part.CanCollide,
                        Massless = part.Massless
                    }
                end
                part.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                part.Transparency = 0.6
                part.CanCollide = false
                part.Massless = true
            end
        end
    end
end

local function restoreAll()
    for plr, data in pairs(originalData) do
        if plr.Character and plr.Character:FindFirstChild(selectedPart) then
            local part = plr.Character[selectedPart]
            if part then
                part.Size = data.Size
                part.Transparency = data.Transparency
                part.CanCollide = data.CanCollide
                part.Massless = data.Massless
            end
        end
    end
    originalData = {}
end

-- ======================= OBSIDIAN - SOLO PARA PC =======================
local HitboxBox = Tabs.Combat:AddLeftGroupbox("Hitbox Bypass", "target")

-- Toggle principal (PC)
HitboxBox:AddToggle("HitboxPC", {
    Text = "Hitbox",
    Default = false,
    Tooltip = "NYX EXOTIC 2025 - Bypass Byfron",
    Callback = function(state)
        hitboxEnabled = state

        if hitboxEnabled then
            if connection then connection:Disconnect() end
            connection = RunService.Heartbeat:Connect(expand)
            Library:Notify("NYX Hitbox ‚ûú ON", 3)
        else
            if connection then connection:Disconnect() connection = nil end
            restoreAll()
            Library:Notify("NYX Hitbox ‚ûú OFF", 3)
        end
    end
})

-- Dropdown para cambiar parte
HitboxBox:AddDropdown("HitboxPart", {
    Values = availableParts,
    Default = 1,
    Text = "Body Part",
    Callback = function(part)
        if hitboxEnabled then
            restoreAll()
            selectedPart = part
            task.wait(0.05)
            expand()
        else
            selectedPart = part
        end
        Library:Notify("Parte: " .. part, 2)
    end
})

-- Slider para tama√±o
HitboxBox:AddSlider("HitboxSize", {
    Text = "Size",
    Default = 0,
    Min = 0,
    Max = 30,
    Rounding = 1,
    Callback = function(value)
        hitboxSize = value
        if hitboxEnabled then
            task.spawn(expand)
        end
    end
})

local AntiAFKConnection
CharacterBox:AddToggle("Anti-AFK", {
    Text = "Anti-AFK",
    Default = false,
    Callback = function(state)
        if state then
            AntiAFKConnection = game:GetService("Players").LocalPlayer.Idled:Connect(function()
                game:GetService("VirtualUser"):ClickButton2(Vector2.new())
            end)
            Library:Notify("Anti-AFK Activado", 3)
        else
            if AntiAFKConnection then
                AntiAFKConnection:Disconnect()
                AntiAFKConnection = nil
            end
            Library:Notify("Anti-AFK Desactivado", 3)
        end
    end
})

local function UltraLowGraphics()
    -- 1. Forzar calidad gr√°fica al m√≠nimo
    settings().Rendering.QualityLevel = Enum.QualityLevel.Level01

    game.Lighting.GlobalShadows = false
    game.Lighting.FogEnd = 9e9
    game.Lighting.Brightness = 1
    if game.Lighting:FindFirstChild("Atmosphere") then
        game.Lighting.Atmosphere:Destroy()
    end

    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Smoke") 
        or obj:IsA("Fire") or obj:IsA("Sparkles") or obj:IsA("Beam") 
        or obj:IsA("Decal") or obj:IsA("Texture") or obj:IsA("SurfaceAppearance") then
            obj:Destroy()
        end
    end

    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") then
            -- Quitar textura/material visual
            obj.Material = Enum.Material.Plastic       -- o SmoothPlastic / ForceField
            obj.Color = Color3.new(0.5, 0.5, 0.5)       -- color gris neutro (opcional)
            
            -- Si tiene MeshPart con textura
            if obj:IsA("MeshPart") then
                obj.TextureID = ""                      -- eliminar textura del mesh
                obj.Material = Enum.Material.SmoothPlastic
            end
        end

        if obj:IsA("SpecialMesh") or obj:IsA("BlockMesh") or obj:IsA("CylinderMesh") then
            obj.TextureId = ""
        end
    end

    for _, effect in ipairs(game.Lighting:GetChildren()) do
        if effect:IsA("PostEffect") then
            effect.Enabled = false
        end
    end

    Library:Notify("Ultra Low Graphics ACTIVADO (Texturas eliminadas +200 FPS)", 5)
end

CharacterBox:AddToggle("UltraLowGFX", {
    Text = "Low Graphic",
    Default = false,
    Tooltip = "Elimina TODAS las texturas de Parts/Modelos + part√≠culas + sombras",
    Callback = function(state)
        if state then
            UltraLowGraphics()
        else
            Library:Notify("Reinicia el juego para restaurar texturas", 4)
        end
    end
})

local InstaProx_Enabled = false
local InstaProx_HookConn = nil
local InstaProx_RemoveConn = nil
local InstaProx_Originals = {} 

local function applyInstaProx(prompt)
    task.spawn(function()
        task.wait(math.random(5,15)/100)
        local hold = prompt.HoldDuration
        local maxd = prompt.MaxActivationDistance
        local los = prompt.RequiresLineOfSight
        
        InstaProx_Originals[prompt] = {hold, maxd, los}
        
        pcall(function()
            prompt.HoldDuration = 0
            prompt.MaxActivationDistance = math.huge
            prompt.RequiresLineOfSight = false
        end)
    end)
end

local function restoreInstaProx()
    for prompt, orig in pairs(InstaProx_Originals) do
        if prompt and prompt.Parent then
            pcall(function()
                prompt.HoldDuration = orig[1]
                prompt.MaxActivationDistance = orig[2]
                prompt.RequiresLineOfSight = orig[3]
            end)
        end
    end
    InstaProx_Originals = {}
end

local function applyToExisting()
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("ProximityPrompt") then
            applyInstaProx(obj)
        end
    end
end

CharacterBox:AddToggle("InstaProximity", {
    Text = "Insta Proximity - (In Testing)",
    Default = false,
    Tooltip = "Activa prompts instant√°neos (Hold 0, distancia infinita, sin LOS) - Ultra Safe",
    Callback = function(state)
        InstaProx_Enabled = state
        
        if state then
            -- ACTIVAR
            applyToExisting()
            InstaProx_HookConn = workspace.DescendantAdded:Connect(function(obj)
                if obj:IsA("ProximityPrompt") then
                    applyInstaProx(obj)
                end
            end)
            InstaProx_RemoveConn = workspace.DescendantRemoving:Connect(function(obj)
                InstaProx_Originals[obj] = nil
            end)
            Library:Notify("Insta Proximity ‚Üí ON", 4)
        else
            -- DESACTIVAR
            restoreInstaProx()
            if InstaProx_HookConn then InstaProx_HookConn:Disconnect() end
            if InstaProx_RemoveConn then InstaProx_RemoveConn:Disconnect() end
            InstaProx_HookConn = nil
            InstaProx_RemoveConn = nil
            Library:Notify("Insta Proximity ‚Üí OFF", 3)
        end
    end
})

game.Players.LocalPlayer.CharacterRemoving:Connect(function()
    if InstaProx_Enabled then
        restoreInstaProx()
    end
end)

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Guardar valores originales
local OriginalNameText = ""
local OriginalRankText = ""

-- Ruta exacta que me diste
local function GetNameLabel()
    local char = workspace.Characters:FindFirstChild(LocalPlayer.Name)
    if not char then return nil end
    
    local head = char:FindFirstChild("Head")
    if not head then return nil end
    
    local nametag = head:FindFirstChild("NameTag")
    if not nametag then return nil end
    
    local mainframe = nametag:FindFirstChild("MainFrame")
    if not mainframe then return nil end
    
    return mainframe:FindFirstChild("NameLabel")
end

local function GetRankLabel()
    local char = workspace.Characters:FindFirstChild(LocalPlayer.Name)
    if not char then return nil end
    
    local head = char:FindFirstChild("Head")
    if not head then return nil end
    
    local ranktag = head:FindFirstChild("RankTag")
    if not ranktag then return nil end
    
    local mainframe = ranktag:FindFirstChild("MainFrame")
    if not mainframe then return nil end
    
    return mainframe:FindFirstChild("NameLabel")
end

-- Aplicar texto personalizado
local function ApplyCustomTags(name, rank)
    local nameLabel = GetNameLabel()
    local rankLabel = GetRankLabel()
    
    if nameLabel and name and name ~= "" then
        nameLabel.Text = name
    end
    if rankLabel and rank and rank ~= "" then
        rankLabel.Text = rank
    end
end

-- Restaurar valores originales
local function ResetTags()
    local nameLabel = GetNameLabel()
    local rankLabel = GetRankLabel()
    
    if nameLabel then
        nameLabel.Text = OriginalNameText
    end
    if rankLabel then
        rankLabel.Text = OriginalRankText
    end
end

-- Guardar originales al cargar personaje
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    local nameLabel = GetNameLabel()
    local rankLabel = GetRankLabel()
    if nameLabel then
        OriginalNameText = nameLabel.Text
    end
    if rankLabel then
        OriginalRankText = rankLabel.Text
    end
end)

-- UI EN EXPLOITS & FUN
ExploitsBox:AddInput("CustomNameTag", {
    Text = "Name Tag - (In Testing)",
    Placeholder = "Tu nombre personalizado",
    Callback = function() end
})

ExploitsBox:AddInput("CustomRankTag", {
    Text = "Rank Tag - (In Testing)",
    Placeholder = "Tu rank personalizado",
    Callback = function() end
})

ExploitsBox:AddButton("Apply Tags", function()
    local name = Library.Options.CustomNameTag.Value
    local rank = Library.Options.CustomRankTag.Value
    ApplyCustomTags(name, rank)
    Library:Notify("Tags aplicados (NameLabel y RankLabel)", 3)
end)

ExploitsBox:AddButton("HideName", function()
    ResetTags()
    Library.Options.CustomNameTag:SetValue("")
    Library.Options.CustomRankTag:SetValue("")
    Library:Notify("Tags restaurados al original", 3)
end)

local Players = game:GetService("Players")
local VirtualInputManager = game:GetService("VirtualInputManager")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

-- DETECCI√ìN EXACTA DE MOBILE (Touch + sin teclado)
local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

-- Crear GUI (siempre en CoreGui para que sea visible)
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "GiveFloatingGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = game:GetService("CoreGui")

local GiveFrame = Instance.new("Frame")
GiveFrame.Size = UDim2.new(0, 110, 0, 30)
GiveFrame.Position = UDim2.new(0, 20, 0.5, -100)  -- Posici√≥n optimizada Mobile
GiveFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
GiveFrame.BorderSizePixel = 0
GiveFrame.Visible = false
GiveFrame.Parent = ScreenGui

local Corner = Instance.new("UICorner")
Corner.CornerRadius = UDim.new(0, 6)
Corner.Parent = GiveFrame

local Border = Instance.new("UIStroke")
Border.Color = Color3.fromRGB(105, 9, 179)
Border.Thickness = 1
Border.Parent = GiveFrame

local GiveLabel = Instance.new("TextLabel")
GiveLabel.Size = UDim2.new(1, 0, 1, 0)
GiveLabel.BackgroundTransparency = 1
GiveLabel.Text = "Give"
GiveLabel.TextSize = 14
GiveLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
GiveLabel.Font = Enum.Font.GothamBold
GiveLabel.Parent = GiveFrame

-- Efecto press (morado)
GiveFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        TweenService:Create(GiveFrame, TweenInfo.new(0.1), {BackgroundColor3 = Color3.fromRGB(141, 35, 222)}):Play()
    end
end)

GiveFrame.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        TweenService:Create(GiveFrame, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(25, 25, 25)}):Play()
    end
end)

-- SIMULAR TECLA Q (humanized)
local function SimulateQ()
    local hold = math.random(60, 140) / 1000
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Q, false, game)
    task.wait(hold)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
end

GiveFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        SimulateQ()
    end
end)

-- TOGGLE EN CHARACTERBOX - SOLO FUNCIONAL EN MOBILE
CharacterBox:AddToggle("ShowGiveFloating", {
    Text = "Show Give (Mobile Only)",
    Default = false,
    Tooltip = "Muestra bot√≥n flotante 'Give' - SOLO funciona en Mobile",
    Callback = function(state)
        -- Si es PC ‚Üí bloquea el toggle y fuerza OFF
        if not isMobile then
            Library.Options.ShowGiveFloating:SetValue(false)  -- Fuerza OFF
            Library:Notify("‚ùå Esta funci√≥n SOLO est√° disponible en Mobile", 5)
            return
        end

        -- Solo en Mobile permite cambiar el estado
        GiveFrame.Visible = state

        if state then
            Library:Notify("Bot√≥n Give ‚Üí ON (Mobile)", 5)
        else
            Library:Notify("Bot√≥n Give ‚Üí OFF", 3)
        end
    end
})


local Players = game:GetService("Players")
local VirtualInputManager = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local CLIPS = {"Drum Magazine","Heavy Magazine","Speed Loader","Extended Clip","Standard Clip"}

getgenv().AutoSpendSpamEnabled = false
local AutoSpendSpamConnection = nil

local function UseClipSpam()
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("Humanoid") then return false end

    local tool = nil
    local bp = LocalPlayer.Backpack

    for i = 1, #CLIPS do
        tool = bp:FindFirstChild(CLIPS[i])
        if tool then break end
    end

    if not tool then
        for i = 1, #CLIPS do
            tool = char:FindFirstChild(CLIPS[i])
            if tool then break end
        end
    end

    if tool then
        if tool.Parent == bp then
            char.Humanoid:EquipTool(tool)
            task.wait(0.1) 
        end

        VirtualInputManager:SendMouseButtonEvent(0,0,0,true,game,0)
        task.wait(0.05 + math.random(1,5)/100)  -- Hold ultra corto
        VirtualInputManager:SendMouseButtonEvent(0,0,0,false,game,0)

        return true
    else
        return false
    end
end

local function StartAutoSpendSpam()
    if getgenv().AutoSpendSpamEnabled then return end
    getgenv().AutoSpendSpamEnabled = true

    Library:Notify("Auto Spend Spam ‚Üí ON (consume TODOS los clips R√ÅPIDO)", 5)

    AutoSpendSpamConnection = RunService.Heartbeat:Connect(function()
        if not getgenv().AutoSpendSpamEnabled then return end

        local hasClip = UseClipSpam()

        if not hasClip then
            getgenv().AutoSpendSpamEnabled = false
            Library.Options.AutoSpendSpamToggle:SetValue(false)
            Library:Notify("Auto Spend Spam ‚Üí OFF (todos los clips consumidos)", 5)
            if AutoSpendSpamConnection then
                AutoSpendSpamConnection:Disconnect()
                AutoSpendSpamConnection = nil
            end
        end
    end)
end

local function StopAutoSpendSpam()
    getgenv().AutoSpendSpamEnabled = false
    if AutoSpendSpamConnection then
        AutoSpendSpamConnection:Disconnect()
        AutoSpendSpamConnection = nil
    end
    Library:Notify("Auto Spend Spam ‚Üí OFF", 3)
end

CharacterBox:AddToggle("AutoSpendSpamToggle", {
    Text = "Auto Spend Clip",
    Default = false,
    Tooltip = "Consume TODOS los clips lo m√°s R√ÅPIDO posible (spam safe). Se apaga solo al terminar",
    Callback = function(state)
        if state then
            StartAutoSpendSpam()
        else
            StopAutoSpendSpam()
        end
    end
})

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetFolder("NyxExotic")
ThemeManager:SetFolder("NyxExotic")
ThemeManager:ApplyToTab(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Tabs.Settings:AddLeftGroupbox("Menu"):AddToggle("CustomCursor", {
    Text = "Custom Cursor",
    Default = true,
    Callback = function(v) Library.ShowCustomCursor = v end
})
Tabs.Settings:AddLeftGroupbox("Menu"):AddLabel("Menu Bind: M (Fixed)")
Tabs.Settings:AddLeftGroupbox("Menu"):AddButton("Unload", function() Library:Unload() end)

-- Tecla 
game:GetService("UserInputService").InputBegan:Connect(function(i, gp)
    if not gp and i.KeyCode == Enum.KeyCode.M then Library:Toggle() end
end)

Library:Notify("Nyx Exotic, [Open Menu] (M)", 6)
SaveManager:LoadAutoloadConfig()


Library:Notify("Nyx Exotic, [Open Menu] (M)", 6)
SaveManager:LoadAutoloadConfig()
